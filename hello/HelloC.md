# 开头的话

> 本文章是对廖雪峰老师的文章笔记以及个人理解和简单扩展，原文在[C 语言入门](https://wangdoc.com/clang/)，望老师理解，侵权请联系删除

- 话说在开头，这个文章是**同时为了 C 和 C++编写的**，但是这两个语言基本上不一样，也不是说 C++就是 C 的超集，**二者不可相提并论**，知乎上有一个[非常棒的回答](https://www.zhihu.com/question/28834538)**"C 是中餐刀，啥事都用一把菜刀完成，C++是西餐刀，种类很多"**
- 那为何我要同时写两个~~还是懒~~，因为**第一部分会详细介绍计算机的运行方式**，从最底层开始理解汇编语言 (没错会浅谈一下汇编 ) ，再从汇编理解 C，当讲完 C 的基本入门 (也就是所有基础功能已经掌握时 ) ，再开始讲解 C++,C++里面一些相似或是重复的概念就一笔带过了
- 为何不讲全部功能，比如 C 的实战开发一类，这是因为这个文章**只是新手入门**，之后还会有一篇讲解 Java 的，还有 Python,Kotlin,Rust,Go······太多了，但是所有的这些语言大都是基于 C (或 C++ ) 写成的编译器 (或解释器 ) ，只有先了解了 C 和计算机的运行原理，去理解那些高级语言才会方便得多
- 没错，C 现在看来已经快落伍了，除非你是操作系统开发等接触到计算机底层的开发人员，C 并不如其他高级语言用起来顺手，但是他依旧简洁高效，基本功能毫不落后，但是痛点也摆在那里 (面向对象，错误处理··· ) ，也不是说不支持 (水平高的完全可以自己写一个 ) ，但是编程的第一思想：**_能拿来用就绝不自己写_**
- 虽然如此，如果你没看过之前的 HelloPython 的话，我也建议你先看那篇再回来，因为**培养编程兴趣**是很重要的，而且在 Python 那里讲了很多编程逻辑，语言规范，这些是不会重复的
- 好了，废话不多说，让我们开始 C 的学习

# 计算机原理

## 第一章：什么是计算机

- 一个看似十分简单的问题却要花费一章来讲解，但其实讲的并不全面，硬件茶谈有一个[带你认识 CPU](https://www.bilibili.com/video/BV1nL411x7jH/)视频讲的很好也很直观，不想深入了解的话可以看看

### 1.逻辑门

- 先说很重要的一句话：
  > 无论多高级的现代计算机，它们**_本质上都只能处理 0 和 1 的带电信号_**，无论你看到电影，游戏还是命令行，在计算机看来都是 001010100110···这样的数据
- 计算机的核心是 CPU，其他所有外设都建立在 CPU 的工作原理上
  > 计算机以二进制形式运行。他们只了解两种状态：开和关。为了以二进制形式进行计算，他们使用所谓的晶体管。晶体管只允许源电流在栅极两端有电流流过漏极时流向漏极。从本质上讲，这形成了一个二进制开关，它根据第二个输入信号切断电线

> 关于更详细的原理这里不再赘述，请自行查阅 MOSFET 是如何实现逻辑门的

- 使用几个晶体管便可以形成逻辑门，它只用*有电*和*没电*这两个状态进行计算，**_高，低电平可以分别二进制当中的 1 和 0_**，从而实现逻辑运算，任何复杂的数学计算都可以靠逻辑运算堆叠而成
- 逻辑门接受两个二进制输入，对它们执行操作，然后返回输出

1. OR 或门：
   **_或门有两个输入端，一个输出端，只要输入信号有一个高电平 1，输出就为高电平 1，只有输入均为低电平，才输出低电平 0_**

| INPUT |     | OUTPUT  |
| ----- | --- | ------- |
| A     | B   | A AND B |
| 0     | 0   | 0       |
| 0     | 1   | 1       |
| 1     | 0   | 1       |
| 1     | 1   | 1       |

2. AND 与门：
   **_与门有两个输入端，一个输出端，当所有的输入同时为高电平 1，输出才为高电平 1，否则输出为低电平 0_**

| INPUT |     | OUTPUT  |
| ----- | --- | ------- |
| A     | B   | A AND B |
| 0     | 0   | 0       |
| 0     | 1   | 0       |
| 1     | 0   | 0       |
| 1     | 1   | 1       |

3. NOT 非门：
   **_非门有一个输入和一个输出端，输入 1 输出 0，输入 0 输出 1，输入端和输出端的电平状态总是反相的_**

| INPUT | OUTPUT |
| :---: | :----: |
|   0   |   1    |
|   1   |   0    |

4. NAND 与非门：
   **_将与门后面加了一个非门，本来输出 0 的输出 1_**

| INPUT |     | OUTPUT  |
| ----- | --- | ------- |
| A     | B   | A AND B |
| 0     | 0   | 1       |
| 0     | 1   | 1       |
| 1     | 0   | 1       |
| 1     | 1   | 0       |

5. NOR 或非门：
   **_将或门后面加了一个非门_**

| INPUT |     | OUTPUT  |
| ----- | --- | ------- |
| A     | B   | A AND B |
| 0     | 0   | 1       |
| 0     | 1   | 0       |
| 1     | 0   | 0       |
| 1     | 1   | 0       |

6. XOR 异或门：
   **_只有两个输入不同才输出 1，相同则输出 0_**

| INPUT |     | OUTPUT  |
| ----- | --- | ------- |
| A     | B   | A AND B |
| 0     | 0   | 0       |
| 0     | 1   | 1       |
| 1     | 0   | 1       |
| 1     | 1   | 0       |

7. XNOR 同或门：
   **_同理相反，只有输入相同才输出 1，否则输出 0_**

| INPUT |     | OUTPUT  |
| ----- | --- | ------- |
| A     | B   | A AND B |
| 0     | 0   | 1       |
| 0     | 1   | 0       |
| 1     | 0   | 0       |
| 1     | 1   | 1       |

- 通过这些基本逻辑门，就可以实现加减乘除运算
  > 这里不放图了，网上有组合图
- 那他会计算了，数又怎么表示？

### 2. 机器码

- **_一个数在计算机中的二进制表示形式，叫做这个数的机器数_**，**机器数是带符号**的，在计算机用机器数的最高位存放符号，正数为 0，负数为 1
  > 比如，十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 0000 0011，如果是 -3 ，就是 100 00011  
  > 那么，这里的 0000 0011 和 1000 0011 就是机器数
- 机器数的真值
  > 因为第一位是符号位，所以机器数的形式值就不等于真正的数值

> 例如上面的有符号数 1000 0011，其最高位 1 代表负，其真正数值是 -3，而不是形式值 131 (1000 0011 转换成十进制等于 131 ) 。所以，为区别起见，**_将带符号位的机器数对应的真正数值称为机器数的真值_**

> 例：0000 0001 的真值 = +000 0001 = +1，1000 0001 的真值 = –000 0001 = –1

- 原码、反码、补码是机器存储一个具体数字的编码方式

1. 原码：

- **_原码是符号位加上真值的绝对值_**
- 原码是人脑最容易理解和计算的表示方式
  > 即用第一位表示符号，其余位表示值。比如：如果是 8 位二进制：

```
[+1]原= 0000 0001

[-1]原= 1000 0001
```

> 第一位是符号位，因为第一位是符号位，所以 8 位二进制数的取值范围就是： (即第一位不表示值，只表示正负。 )

```
[1111 1111 , 0111 1111]

即

[-127 , 127]
```

2. 反码：

- **_正数的反码是其本身_**
- **_负数的反码是在其原码的基础上，符号位不变，其余各个位取反_**

```
如：

[-1] = [1000 0001]原= [1111 1110]反
```

3. 补码：

- **_正数的补码就是其本身_**
- **_负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。 (也即在反码的基础上+1 )_**

```
如：

[+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补

[-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补
```

- 对于正数，三种表达方式均一样，但复数就不是了
- **_之所以这么复杂，就是为了实现减法，加上一个数等于减去这个数的相反数，但是直接跟复数的机器码加减会出错，如果再让机器专门有电路识别符号位又太复杂了，所以弄出反码，但是反码会出现+-0 这种情况，所以补码出现_**
- 这里只是简单说，真正理解可以看一篇[知乎上的文章](https://zhuanlan.zhihu.com/p/118432554)
- 请记住，一般的数字均已补码存储

### 3. 寄存器

- 但是这里我们的 CPU 还只是一个光会算数的空壳子，还需要人给他提供数据，他的运算结果又该往哪里放？
- **_CPU = ALU + CU_**
- **_ALU 算术逻辑单元 (Arithmetic&logical Unit )_**：是中央处理器 (CPU ) 的执行单元，是所有中央处理器的核心组成部分，由"And Gate" (与门 ) 和"Or Gate" (或门 ) 构成的算术逻辑单元，主要功能是进行二位元的算术运算，如加减乘 (不包括整数除法 ) 。基本上，在所有现代 CPU 体系结构中，二进制都以补码的形式来表示
- **_CU 控制单元 (Control Unit )_**：负责程序的流程管理。控制单元是整个 CPU 的指挥控制中心，由指令寄存器 IR (Instruction Register ) 、指令译码器 ID (Instruction Decoder ) 和操作控制器 OC (Operation Controller ) 三个部件组成，对协调整个电脑有序工作极为重要
  > 简单说，**_ALU 负责计算，CU 负责控制数据的传输_**

### 4.CPU 的工作流程

- CPU 的基本工作是**_执行存储的指令序列，即程序_**，**_程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程_**
- **_程序的执行_**：

```
开始 → 取指令 → 指令译码 → 执行指令 → 开始
```

- **_指令的执行_**：  
   1. 取指令阶段：
  **_取指令 (Instruction Fetch，IF ) 阶段_**是将一条指令从主存中取到指令寄存器的过程，
  程序计数器 PC 中的数值，用来指示当前指令在主存中的位置。当一条指令被取出后，PC 中的数值将根据指令字长度而自动递增 2. 指令译码阶段：
  取出指令后，计算机立即进入**_指令译码 (Instruction Decode，ID ) 阶段_**，
  在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法 3. 执行指令阶段：
  在取指令和指令译码阶段之后，接着进入**_执行指令 (Execute，EX ) 阶段_**，
  此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。为此，CPU 的不同部分被连接起来，以执行所需的操作 4. 访存取数阶段：
  根据指令需要，有可能要访问主存，读取操作数，这样就进入了**_访存取数 (Memory，MEM ) 阶段_**，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算 5. 结果写回阶段：
  作为最后一个阶段，**_结果写回 (Write Back，WB ) 阶段_**把执行指令阶段的运行结果数据“写回”到某种存储形式，结果数据经常被写到 CPU 的内部寄存器中，以便被后续的指令快速地存取；在有些情况下，结果数据也可被写入相对较慢、但较廉价且容量较大的主存。许多指令还会改变程序状态字寄存器中标志位的状态，这些标志位标识着不同的操作结果，可被用来影响程序的动作，在指令执行完毕、结果数据写回之后，若无意外事件 (如结果溢出等 ) 发生，计算机就接着从程序计数器 PC 中取得下一条指令地址，开始新一轮的循环，下一个指令周期将顺序取出下一条指令
  > 现代 CPU 的设计原理，基本都建立在几十年前的**冯诺依曼体系**上

## 第二章：如何控制一台计算机 (汇编浅尝辄止 )

- 根据之前讲的，电脑只能明白 001101 这种二进制语言，那么编程时的语句又是如何被执行的？
- 计算机真正能够理解的是低级语言，它专门用来控制硬件，汇编语言就是低级语言，直接描述/控制 CPU 的运行

### 1.什么是汇编

- CPU 本身不具备只能，它只能计算，然后等待下一条指令，继续计算
- 早期的电脑操作员觉得每次手动输入那些二进制的指令 (比如加法 ) ，不仅不可读而且容易出错
- 所以**_汇编语言_** (assembly language,ASM ) 出现了，**_他就是二进制指令的文字版_**，比如加法就是 ADD，**把文本转成二进制的过程就是汇编**
- 每一种 CPU 的指令不同，自然汇编指令也不同，本文介绍的是 X86 (或 AMD64 )

### 2.寄存器

- 之前说过 CPU 本身并不存储数据，是由内存提供，但是**_CPU 的运行速度一般远高于内存，所以 CPU 一般自带缓存_** (比如一缓二缓 )
- CPU 自带的**_寄存器 (register ) ，用来储存最常用的数据_**，也就是说，那些最频繁读写的数据 (比如循环变量 ) ，都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据，省的 CPU 来回读写
- **_寄存器不依靠地址区分数据，而依靠名称_**，每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的，寄存器就像是 CPU 的零级缓存
- 早期 CPU 只有八个寄存器，虽然现在的 CPU 肯定更多了，但最开始的这几个的名字保留了下来

```py
EAX

EBX

ECX

EDX

EDI

ESI

EBP

ESP

# 前七个都是通用的，最后一的特殊作用见后
```

- **_32 位和 64 位就是形容寄存器的大小_**，32 位 CPU 的寄存器可以一次使用 32 位的数据 (32bit 也等于 4Byte ) ，64 位的可以一次使用 8Byte 的数据 (32 位 CPU 地址总线不超过 32，它所能达到的寻址范围，理论上只能使用约 4GB，即不超过 2 的 32 次方字节；64 位 CPU，理论上寻址范围可以达到上亿 GB (2 的 64 次方字节 ) ，所以基本上 128 位 CPU 进入个人电脑还很远 )

### 3.内存模型 _Heap_

- 当然，如果 CPU 需要一次处理很多的数据，还是要跟内存交流的
- **_程序运行的时候，操作系统会给它分配一段内存_**，用来储存程序和运行产生的数据。**_这段内存有起始地址和结束地址_**，比如从 0x1000 到 0x8000，_起始地址是较小的那个地址_，_结束地址是较大的那个地址_
- 程序运行过程中，对于**_动态的内存占用请求 (比如新建对象 )_**，系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是**_从起始地址开始划分_**，举例来说，用户要求得到 10 个字节内存，那么从起始地址 0x1000 开始给他分配，一直分配到地址 0x100A，如果再要求得到 22 个字节，那么就分配到 0x1020
- 这种**_因为用户主动请求而划分出来的内存区域，叫做 Heap (堆 )_**，它**由起始地址开始，从低位向高位增长**，Heap 的一个重要特点就是**_不会自动消失_**，必须手动释放，或者*由垃圾回收机制来回收*

### 4. 内存模型 _Stack_

- 除了 Heap 以外，其他的内存占用叫做 Stack (栈 ) ，Stack 是由于函数运行而临时占用的内存区域

```c
int main(){
    int a = 5
    int b = 7
    return a + b
}

// 上面的代码执行时，会为它在内存里面建立一个帧  (frame ) ，所有main的内部变量  (比如a和b ) 都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间
```

- 那如果在函数内部再调用函数呢？

```c
int main(){
    int a = 8
    int b = 3
    c = add(a,b)
    return c
}

// main函数内部调用了add函数。执行到这一行的时候，系统也会为add新建一个帧，用来储存它的内部变量，也就是说，此时同时存在两个帧：main和add，一般来说，调用栈有多少层，就有多少帧

// 等到add运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行，通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量
```

- **_所有的帧都存放在 Stack_**，由于*帧是一层层叠加*的，所以 Stack 叫做**_栈_**，生成新的帧，叫做**_入栈 push_**；栈的回收叫做**_出栈 pop_**，Stack 的特点就是，**_最晚入栈的帧最早出栈 (因为最内层的函数调用，最先结束运行 ) 后进先出_**的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了
- **_Stack 是由内存区域的结束地址开始_**，从*高位 (地址 ) 向低位 (地址 ) 分配*，比如，内存区域的结束地址是 0x8000，第一帧假定是 16 字节，那么下一次分配的地址就会从 0x7FF0 开始；第二帧假定需要 64 字节，那么地址就会移动到 0x7FB0

### 5.CPU 指令

- 通过 gcc 把一个简单的 c 文件编译为汇编语言

```c
$ gcc -S example.c

// 在上
```

```c
_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8]
   mov    %ebx, [%esp+12]
   add    %eax, %ebx
   pop    %ebx
   ret

_main:
   push   3
   push   2
   call   _add_a_and_b
   add    %esp, 8
   ret

// 这就是简化过的汇编指令

// 不同的指令push,mov,add
```

- 真正详细的不会介绍，这里主要是浅尝辄止，明白汇编是怎样工作的

### 6.进程

- 我们编写一个程序源文件之后，编译得到的二进制可执行文件存放在电脑的硬盘上，此时它是**_一个静态的文件，一般称之为程序_**
- 当这个程序被启动的时候，操作系统将会做下面几件事情：
  > 把程序的内容(代码段、数据段)从硬盘复制到内存中  
  > 创建一个数据结构 PCB(进程控制块)，来描述这个程序的各种信息(例如：使用的资源，打开的文件描述符...)  
  > 在代码段中定位到入口函数的地址，让 CPU 从这个地址开始执行
- 当程序开始被执行时，就变成**_一个动态的状态，一般称之为进程_**

## 第三章：数据结构与算法

> 这部分可能会非常复杂抽象，所以这里只是简单介绍，会随着下一章慢慢介绍

- **_程序 = 数据结构 + 算法_**
- 一个程序谁都会写，但是写的好坏就看数据结构和算法了

### 1.算法入门

- **_算法 (algorithm ) 是指令的集合_**，是为解决特定问题而规定的一系列操作，它是**明确定义的可计算过程**，**以一个数据集合作为输入，并产生一个数据集合作为输出**
- 算法的五个特性
  > **输入**：以待解决的问题作为输入  
  > **输出**：处理后得到的信息  
  > **可行性**：每一条指令都可以实现  
  > **有穷性**：整个算法都可以在有限时间内结束  
  > **确定性**：对于相同的合法输入，输出结构唯一
- 算法就是计算机解题的过程，**_解题思路是算法的逻辑形式，编写程序是算法的代码形式_**
- **_评价算法优劣的依据：复杂度_** 1. 时间复杂度：  
  **_时间频度_**：**_一个算法在完成的时候 最基础代码执行的次数_**，一个算法花费的时间与算法中语句的执行次数成正比例，**_一个算法中的语句执行次数称为语句频度或时间频度_**  
  当数据规模产生变化时，**_时间频度的变化趋势的量级可以理解为时间复杂度_** 2. 空间复杂度：
  **_当数据规模放生变化时 计算占用空间的变化趋势叫空间复杂度 (不包含输入及输出 )_**

### 2.排序

- **_排序 (sorting ) 的功能是将一个数据元素的任意序列，重新排列成一个按关键字有序的序列_**
- 一类是整个排序过程**_在内存储器中进行，称为内部排序_**；另一类是由于待排序元素数量太大，以至于内存储器无法容纳全部数据，排序**_需要借助外部存储设备才能完成，这类排序称为外部排序_** (本文介绍内排序 )
- 大部分**_依靠比较来判断大小作为排序依据，这叫比较排序_** (比如最基本的下文三种 ) ，另一种**_不需要进行比较，叫非比较排序_**虽然效率高但可能会带来其他问题

#### 1. 冒泡排序

1. 整个数列分成两部分：前面是无序数列，后面是有序数列
2. 初始状态下，整个数列都是无序的，有序数列是空
3. 如果一个数列有 n 个元素，则至多需要 n-1 趟循环才能保证数列有序
4. 每一趟循环可以让无序数列中最大数排到最后， (也就是说有序数列的元素个数增加 1 )
5. 每一趟循环都从数列的第一个元素开始进行比较，依次比较相邻的两个元素，比较到无序数列的末尾即可 (而不是数列的末尾 )
6. 如果前一个大于后一个，交换

- 注意没有必要每一次都比较到最后面，一次是比一次少的
- 如果有序也可以直接退出

#### 2. 选择排序

1. 整个数列分成两部分：前面是有序数列，后面是无序数列
2. 初始状态下，整个数列都是无序的，有序数列是空
3. 一共 n 个数，需要 n-1 趟循环 (一趟都不能少 )
4. 每比较完一趟，有序数列数量+1，无序数列数量-1
5. 每趟先假设无序数列的第 1 个元素 (整个数列的第 i 个元素 ) 是最小的，让当前的最小数，从第 i+1 个元素开始比较，一直比较到最后一个元素。如果发现更小的数，就假设当前数是最小数。
6. 一趟比较完后，将发现最小数和无序数列的第一个数交换 (如果最小数不是无序数列的第一个数 )

#### 3. 直接插入排序

1. 将数组分成两个区域，一个是有序区域一个是无序区域，最开始初始化有序区域为第一个数
2. 将无序区域第一个数与有序区域作比较，判断该数适合插入的位置
3. 同理持续到无需区域结束

### 3.递归

- 递归 (recursion ) 是一种常见的解决问题的方法，即把问题逐渐简单化，递归的基本思想就是**自己调用自己**
- 一个问题可被分解为若干层简单的子问题，子问题和其上层问题的解决方案一致，外层问题的解决依赖于子问题的解决
- 但是递归调用会占用大量的系统堆栈，内存耗用多，任何能用递归解决的问题也能用迭代解决
- 使用递归的折半查找
  - 查找表必须使用顺序存储结构，大小有序排列
  - 通过不断的拆分，判断中间值与目标值的大小来定位

```
查找6

1,5,6,9,15,46,89,102
↑         ↑       ↑
low      mid      high
↑   ↑     ↑
low mid  high
```

### 4.数据结构

- **_数据结构就是存储数据的方式_**
- **_数据结构 = 逻辑结构 + 存储结构 (存在于计算机世界的物理层面 ) + (在存储结构上的 ) 运算/操作 (算法 )_**

#### 4.1 逻辑结构

- 数据的逻辑结构指**_数据元素之间的逻辑关系_** (和实现无关 )

##### 4.1.1 线性结构

- 线性结构：**_有且只有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继_**，特点是**一对一**

```
01 → 05 → 06 → 02 → 08
```

- 线性表就是一个典型的线性结构，它有四个基本特征：
  - 集合中必存在唯一的一个"第一个元素"
  - 集合中必存在唯一的一个"最后的元素"
  - 除最后元素之外，其它数据元素均有唯一的"直接后继"
  - 除第一元素之外其它数据元素均有唯一的"直接前驱"

##### 4.1.2 树状结构

- 树状结构：**_除了一个数据元素 (元素 01 ) 以外每个数据元素有且仅有一个直接前驱元素，但是可以有多个直接后续元素_**，特点是**一对多**
- 比如 Linux 的文件系统

```
        01
       ↙↘
      05  09
     ↙↘  ↓
    07 02  04
```

##### 4.1.3 网络结构

- 网络结构：**_每个数据元素可以有多个直接前驱元素，也可以有多个直接后续元素_**，特点是数据元素之间是**多对多**的联系

```
01 ↔ 02 ↔ 07
↕     ↕
03 ↔ 06
```

- 比如交通路线图

#### 4.2 存储结构

- 数据的存储结构主要包括**_数据元素本身的存储以及数据元素之间关系_**表示，是数据的逻辑结构在计算机中的表示
- **_同一逻辑结构可以对应多种存储结构_**
- **_同样的运算，在不同的存储结构中，其实现过程是不同的_**

##### 4.2.1 顺序存储结构

- 顺序存储结构：**_把逻辑上相邻的节点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现_** (比如数组 ) ，数据元素的存储对应于一块连续的存储空间，数据元素之间的前驱和后续关系通过数据元素，在存储器中的相对位置来反映

| 0   | 1   | 2   | 3   | ··· | i - 1 | i      | i + 1 | ··· | n   |
| --- | --- | --- | --- | --- | ----- | ------ | ----- | --- | --- |
| a1  | a2  | a3  | a4  | ··· | ai -2 | ai - 1 | ai    | ··· | an  |

##### 4.2.2 链式存储结构

- 链式存储结构：**_数据元素的存储对应的是不连续的存储空间，每个存储节点对应一个需要存储的数据元素_**，每个结点是由数据域和指针域组成。元素之间的逻辑关系通过存储节点之间的链接关系反映，逻辑上相邻节点物理上不必相邻 (比如 Python 的列表 )

```
|head| → | → |a1| → | → |a2| → | → ··· → |an|null|
       ↓      ↙   ↘
      头指针 数据   指针
```

##### 4.3.3 索引存储

- **_除建立存储结点信息外，还建立附加的索引表来标识结点的地址_** (比如字典的目录 )

##### 4.3.4 散列存储

- 散列存储名字中的**_散列就是常听到的 hash (哈希值 )_**，hash 是通过一种算法来运算出来的，比如 MD5
- 在这种存储格式下，**_地址会通过 hash 算法来运算成一个相同长度的 hash 值，然后存放这个 hash 值，而不是直接存放地址_**
- 在访问关键字的时候会**_通过运算解码 hash 值，然后再访问_**，这个时候，节点的存储地址和关键字是有某种映射关系的
- 之所以耗费性能就是为了**_节省空间_**

## 第四章：编译，解释和 C 的历史

- **_编译与解释_**
  - **_编译 (Compile ) 的过程是把整个源程序代码翻译成另外一种代码_**，翻译后的代码等待被执行或者被优化等等，发生在运行之前，产物是另一份代码。
  - **_解释 (Interpret ) 的过程是把源程序代码一行一行的读懂，然后一行一行的执行_**，发生在运行时，**_产物是运行结果_**
- 编译器与解释器
  - 编译器 (Compiler ) 是一种计算机程序，它会将某种编程语言编写的源代码 (原始语言 ) 转换成另一种编程语言 (目标语言 ) ，其实就是完成上文中所说的编译的过程。主要目的是将便于人编写、阅读维护的高级计算机语言所编写的源代码程序，翻译为计算机能运行的机器语言程序
  - 解释器 (interpreter ) ，是一种计算机程序，能够把解释型语言解释执行。其实就是执行解释的过程
- 那么**_C 语言要求先将源码编译成机器码 (比如 exe 可执行文件 ) ，再去运行机器码_**
- 源码可以跨平台，但机器码是不可以的，但是**_有一些语言 (比如 Java ) ，编译后的文件是可以跨平台的_** (当然最后的机器码依旧不行 ) ，但是**_还有一些语言 (比如 Python ) 他没有编译过程，执行时自带的解释器直接解释运行源码_**，也不存在跨平台问题
- **_动态静态类型_**
  - **_动态类型语言不需要声明变量的类型，执行时由赋的值决定_** (比如 Python 就可以，而且命完还可以改变类型！ )
  - **_静态语言在赋值时必须要先声明该值的类型_**
- **_强弱类型语言_**
  - 强类型语言：**\*强制数据类型定义**，一个表变量如果是数就不能是字符串了 (当然可以有其他方法 )
  - 弱类型语言：**_不强制数据类型定义_**，比如 Python (但注意本质上变量的类型没有变化，只是被指向了一个新的内存 )
- C 语言是现代**_高级编程语言里资历最老的一个_**，其领导地位无需多言，Java，Python 等等语言的解释器都是基于 C 的，C 语言从 1972 年在贝尔实验室被发明 (相当超前的一个语言 ) ，距今已经 50 个年头，虽然很多高级功能他没有，但是 C 依旧广受欢迎
- C 语言的好处这里就不再赘述了，一边介绍大家就能自己明白
- 需要注意，C 语言一开始被不同的厂商扩展为自己的版本，后来才发展出不同的标准，分为**_ANSI C，C89，C99，C11，C17，C2x_**，这里如果不另外说明均为最新的标准 (当然自己也可以尝试看看编译器能不能通过 )
- 编写程序的标准步骤：
  - 程序要干什么？
  - 设计程序逻辑
  - 编写代码
  - 编译
  - 运行
  - 调试以及测试
  - 维护和修改
- C 语言的源码保存在"名称.c"中，通过编译器转换为中间代码，链接器把中间代码和其他代码合并，再生成可执行文件

```
源文件 → 编译器 → 中间代码 → 链接器 → 可执行文件
                             ↑
                          其他部分  (库，启动代码 )
```

- 中间代码一般就是机器码，但是还缺少**_启动代码，它充当着程序和操作系统之间的接口_**
- 大部分 C 程序都要使用**_C 标准库_**里的函数

## 第四章：C 的安装

> 差点忘了讲最关键的

- 一般来说需要一个 C 语言的编译器，因为 C 语言出来的很早所以现在的编译器也很多，这里讲一下个人使用的*GCC*
  > 在安装之前请先检查一下你的电脑装了 GCC 没有，我这个 _Debian_ 就是带着的，你在命令行敲一下 _GCC_ 看看有没有出来的，有的话直接跳过
- linux 直接 sudo 安装就行，或者到 [MinGW 的官网](https://www.mingw-w64.org/)找到对应自己的系统，Windows 下面推荐使用 [MinGW 绿色免安装](https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/)，直接解压开添加到环境变量就行，之后 cmd 输入

```c
gcc -v

// 检查是否成功
```

> 个人一直很讨厌不能便携安装的编译器，C 啊 Java，Python 都可以，之前没有写 Rust 就是因为他需要一个 linker 竟然要你装 virtual studio？真是不可理喻，gnu 版本的又报错，cargo 也不过如此嘛

> 之后讲解 Java 的时候会介绍一下 kotlin，很不错的语言而且依赖于 Java 直接互通

# C 语言入门

## 第一章：C 基本概念

### 壹: C 语言的结构与运行

```c
/* 一个简单的示例*/

#include <stdio.h>    // 头文件，包含了程序运行必须的库

int main  (void ) {     // main函数，程序总是从main开始，没有main会报错
    int n;
    n = 1;

    printf  ("this is a sample.\n" ) ;
    printf  ("number n is %d",n ) ;

    return 0
}
```

- 这就是 C 的源码，保存在"名称.c"，要想运行它，可以使用编译器 (以 gcc 举例 )

```c
// 先定位到文件所在的文件夹

gcc hello.c
```

- 运行完后会发现多出一个 _.exe_ (Windows 可执行文件，或者是.out ) 文件，**_双击它运行即可_** (这就是我们说的机器码 ) ，应该在终端能看到打印的文字
  > 如果程序只是一闪而过，可以添加如下代码在 return 前面，**_getchar ( ) 会让程序等待用户输入后再关闭_**
- 使用 _-o 和 std 参数_

```c
gcc -o hello_world hello.c

// 指定输出的名称

gcc -std=c99 hello.c

// 指定以什么标准进行编译
```

### 贰: 基本语法

#### 1.令牌

- C 程序由各种令牌组成，**_令牌可以是关键字、标识符、常量、字符串、运算符、分隔符_**
- **_它是程序中最小的不可分割单元_**

```c
int a = 6;

// 令牌是

int
a
=
6
;

```

#### 2.语句

- C 语言的**_代码由一行行语句 (statement ) 组成，语句就是程序执行的一个操作命令，语句必须使用分号结尾_**

```c
int a;

// 一个声明语句
```

- 语句之间没有硬性要求，**_只要有分号就看做一个语句_**，因此以下写法都合规但是不建议

```c
int a=1;a=a+1;return a;

// 不要挤在一块，合理换行

int b;
b
=
1
;

// 不要这么做
```

- 语句的种类有很多，比如*声明语句，表达式语句，控制语句，复合语句，空语句*，后面会慢慢讲到，概念没必要记

#### 3.表达式

- 用来计算的**_用运算符把运算数连接起来的式子就是表达式_**

```c
1 + 2

// 表达式
```

```c
1 + 2;

// 加上分号之后变成语句，但是没有作用
```

- 语句可以包含表达式，但是表达式本身不构成语句
- **_表达式都有返回值，语句不一定有_**，因为语句用来执行某个命令，很多时候不需要返回值，比如变量声明语句 (int x = 1; ) 就没有返回值

#### 4.语句块

- C 语言允许多个语句使用**_一对大括号{}，组成一个块，也称为复合语句_** (compounded statement ) ，在语法上，**_语句块可以视为多个语句组成的一个复合语句_**

```c
int a = 5;
{
    int a = 6;

    // 同名变量a在代码块内定义为6，出来之后无效
}
a = 7;
```

- **_代码中定义的变量都叫局部变量，只在本代码块内有效，内外同名视作两个变量_**

#### 5.空格

- 空格主要用来帮助编译器区分语法单位，如果语法单位不用空格就能区分，**_空格就不是必须的_**，只是为了**_增加代码的可读性_**
- **_多个空格等同于单个空格_**

```c
int a = 2;

// 等同于

int a=2;

// 但是不等同于

inta=2;

// 关键字和标识符还是要分开的
```

- 同理，缩进也不是必要的，只是为了可读性 (有一个[IOCCC](https://www.ioccc.org/) ，专门比赛谁的代码写的令人迷惑 )

```c
int main(void){printf("hello");return 0;}

// 你要写成这样也能编译，但是别人就骂娘了
```

#### 6.注释

- **_注释是对代码的说明，编译器编译时会忽略注释_**
- C 语言有两种注释方式，**_单行和多行注释_** (多行注释 C99 引入请注意 )

```c
/*
    这是一个多行注释
    这是一个多行注释
    这是一个多行注释
*/



/* 这也是一个多行注释 */


// 这是一个单行注释
```

- 允许行内注释

```c
int a=/*hello world*/5;

int a=5; // hello world
```

- 多行注释请注意收尾防止代码也成了注释
- 不管哪种注释都**_不能放在双引号里_**
- **_不能嵌套注释，但可以多行嵌套当行_**

#### 7.printf 函数

- 虽然这里介绍有点早，但是考虑到会经常使用

##### 7.1 语法

```c
printf("hello world");

// 只能是双引号

// printf的定义位于标准库stdio.h，使用的话要先引入
```

- **_printf()的作用是将参数文本输出到屏幕_**，它名字里面的 f 代表 format (格式化 ) ，表示**_可以定制输出文本的格式_**
- printf 打印后不会自动换行，光标仍会留在文字末，**_可以添加换行符_**

```c
printf("hello world \n")
```

##### 7.2 转义字符

    1. \n 换行符
    2. \b 回退符
    3. \r 回车符
    4. \t 横向制表符
    5. \v 纵向制表符
    6. \\\ \\' \\" 为了打出原来的也需要转义  (这里请以渲染为主，因为markdown也会转义 )

##### 7.3 占位符

- **_占位符，就是这个位置可以用其他值代入_**

```c
printf("hello %i world %i . \n",9,8)

// 占位符均以百分号%开头，后面代表代入值的类型
```

- printf()**_参数与占位符是一一对应关系，如果有 n 个占位符，printf()的参数就应该有 n + 1 个_** (因为字符串本身也算 ) ，如果参数个数少于对应的占位符，printf()可能会输出内存中的任意值
- printf()的占位符有许多种类，与 C 语言的数据类型相对应，下面列出常用的占位符，方便查找，具体含义在后面章节介绍

| 名称 | 意义                                        |
| ---- | ------------------------------------------- |
| %a   | 十六进制浮点数，字母输出为小写              |
| %A   | 十六进制浮点数，字母输出为大写              |
| %c   | 字符                                        |
| %d   | 十进制整数                                  |
| %e   | 使用科学计数法的浮点数，指数部分的 e 为小写 |
| %E   | 使用科学计数法的浮点数，指数部分的 E 为大写 |
| %i   | 整数，基本等同于%d                          |
| %f   | 小数 (包含 float 类型和 double 类型 )       |
| %g   | 6 个有效数字的浮点数                        | 整数部分一旦超过 6 位，就会自动转为科学计数法，指数部分的 e 为小写 |
| %G   | 等同于%g，唯一的区别是指数部分的 E 为大写   |
| %hd  | 十进制 short int 类型                       |
| %ho  | 八进制 short int 类型                       |
| %hx  | 十六进制 short int 类型                     |
| %hu  | unsigned short int 类型                     |
| %ld  | 十进制 long int 类型                        |
| %lo  | 八进制 long int 类型                        |
| %lx  | 十六进制 long int 类型                      |
| %lu  | unsigned long int 类型                      |
| %lld | 十进制 long long int 类型                   |
| %llo | 八进制 long long int 类型                   |
| %llx | 十六进制 long long int 类型                 |
| %llu | unsigned long long int 类型                 |
| %Le  | 科学计数法表示的 long double 类型浮点数     |
| %Lf  | long double 类型浮点数                      |
| %n   | 已输出的字符串数量                          | 该占位符本身不输出，只将值存储在指定变量之中 |
| %o   | 八进制整数                                  |
| %p   | 指针                                        |
| %s   | 字符串                                      |
| %u   | 无符号整数 (unsigned int )                  |
| %x   | 十六进制整数                                |
| %zd  | size_t 类型                                 |
| %%   | 输出一个百分号                              |

##### 7.4 输出格式

###### 7.4.1 限定宽度

- printf()允许**_限定占位符的最小宽度_**

```c
printf("%5d\n", 123); // 输出为 "  123"
```

> 上面示例中，%5d 表示这个占位符的宽度至少为 5 位。如果不满 5 位，对应的值的前面会添加空格

- 输出的值默认是右对齐，即输出内容前面会有空格；如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的%的后面插入一个 - 号

```c
printf("%-5d\n", 123); // 输出为 "123  "
```

> 上面示例中，输出内容 123 的后面添加了空格

- 对于小数，这个限定符会限制所有数字的最小显示宽度

```c
// 输出 "  123.450000"
printf("%12f\n", 123.45);
```

> 上面示例中，%12f 表示输出的浮点数最少要占据 12 位，由于小数的默认显示精度是小数点后 6 位，所以 123.45 输出结果的头部会添加 2 个空格

###### 7.4.2 总是显示正负号

- 默认情况下，printf()不对正数显示+号，只对负数显示-号，如果想让正数也输出+号，**_可以在占位符的%后面加一个+_**

```c
printf("%+d\n", 12); // 输出 +12
printf("%+d\n", -12); // 输出 -12
```

> 上面示例中，%+d 可以确保输出的数值，总是带有正负号

###### 7.4.3 限定小数位数

- 输出小数时，有时希望限定小数的位数。举例来说，**_希望小数点后面只保留两位，占位符可以写成%.2f_**

```c
// 输出 Number is 0.50
printf("Number is %.2f\n", 0.5);
```

> 上面示例中，如果希望小数点后面输出 3 位 (0.500 ) ，占位符就要写成%.3f。

- **_这种写法可以与限定宽度占位符，结合使用_**

```c
// 输出为 "  0.50"
printf("%6.2f\n", 0.5);
```

> 上面示例中，%6.2f 表示输出字符串最小宽度为 6，小数位数为 2。所以，输出字符串的头部有两个空格。

- **_最小宽度和小数位数这两个限定值，都可以用 \* 代替，通过 printf()的参数传入_**

```c
printf("%*.*f\n", 6, 2, 0.5);

// 等同于
printf("%6.2f\n", 0.5);
```

> 上面示例中，%*.*f 的两个星号通过 printf()的两个参数 6 和 2 传入

##### 7.5 头文件

- 程序需要用到的功能，不一定需要自己编写，C 语言可能已经自带了。程序员只要去调用这些自带的功能，就省得自己编写代码了。举例来说，printf()这个函数就是 C 语言自带的，只要去调用它，就能实现在屏幕上输出内容。
- **_C 语言自带的所有这些功能，统称为“标准库” (standard library )_**，因为它们是写入标准的，到底包括哪些功能，应该怎么使用的，都是规定好的，这样才能保证代码的规范和可移植。
- **_不同的功能定义在不同的文件里面，这些文件统称为“头文件” (header file )_**。如果系统自带某一个功能，就一定还会自带描述这个功能的头文件，比如 printf()的头文件就是系统自带的 stdio.h。头文件的后缀通常是.h。
- **_如果要使用某个功能，就必须先加载对应的头文件，加载使用的是#include 命令_**。这就是为什么使用 printf()之前，必须先加载 stdio.h 的原因。

```c
#include <stdio.h>
```

> 注意，**_加载头文件的#include 语句不需要分号结尾_**

### 叁: 变量

- **_变量 (variable ) 可以理解成一块内存区域的名字。通过变量名，可以引用这块内存区域，获取里面存储的值。由于值可能发生变化，所以称为变量，否则就是常量了_**

#### 1.标识符和关键字

- C **_标识符是用来标识变量、函数，或任何其他用户自定义项目的名称_**，一个标识符**_以字母或下划线开始，后跟零个或多个字母、下划线和数字_**，标识符内**_不允许出现标点字符_**，比如 @、\$ 和 %，**_区分大小写，长度不能超过 63 个字符_**

| 合法的标识符 | 不合法的标识符 |
| ------------ | -------------- |
| apple        | 1apple         |
| \_banana     | &yu            |
| user_1       | hello world    |
| Hello        | \_name\_       |

- **_关键字 (Keywords ) 是由 C 语言规定的具有特定意义的字符串，也称为保留字_**，如 int、char、long、float、unsigned 、struct、typedef 等，用户所定义的**_标识符不能与关键字相同_**

```c
// 关键字一览

auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while
```

> 后面会慢慢介绍

#### 2.变量名

- **_变量的命名严格遵守标识符命名法则_**
- **_变量名区分大小_**

```c
hello != Hello != HELLO

// 三者不相同
```

- **_变量名不能是关键字_**
- **_两个下划线开头的变量名，以及一个下划线 + 大写英文字母开头的变量名，都是系统保留的，自己不应该起这样的变量名_**

#### 3.声明

- **_C 语言的变量，必须先声明后使用_**，如果一个变量没有声明就直接使用，会报错
- **_每个变量都有自己的类型 (type )_**，声明变量时，必须把变量的类型告诉编译器

```c
int n;

// 声明整数变量n
```

> 数据类型见下页

- **_如果几个变量具有相同类型，可以在同一行声明_**

```c
int n,m,p,q;

// 一次声明四个整数
```

- 声明变量的语句也是语句，必须**_以分号结尾，一旦声明，变量的类型就不能在运行时修改_** (静态类型 )

#### 4.赋值

- C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，**_变量一定要赋值以后才能使用，也叫初始化_**

```c
// 声明与赋值

int a;
a = 3;
  ^
//赋值运算符等号
```

> **_变量的值应该与类型一致，不应该赋予不是同一个类型的值_**，比如 num 的类型是整数，就不应该赋值为小数。虽然 C 语言会自动转换类型，但是应该避免赋值运算符两侧的类型不一致 (类型转换见后文 )

- **_变量的声明和赋值，也可以写在一行_**

```c
int a = 4;
```

- **_多个相同类型变量的赋值，可以写在同一行_**

```c
int x = 1,y = 2;

// 但是底下这样不行

int x,y = 1,2;
```

- **_注意，赋值表达式有返回值，等于等号右边的值_**

```c
int y = (x = x * 2);
```

> 上面代码中，变量 y 的值就是赋值表达式 (x = 2 \* x ) 的返回值 2

- **_由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式_**

```c
m = n = y = x = 9;

// 但是没有多重声明式

int x = y = m = n = 4;

// 违法
```

> 上面的代码是合法代码，一次为多个变量赋值。**_赋值运算符是从右到左执行_**，所以先为 n 赋值，然后依次为 m、z、y 和 x 赋值。

- **_C 语言有左值 (left value ) 和右值 (right value ) 的概念_**。*左值*是可以**放在赋值运算符左边的值，一般是变量**；*右值*是可以**放在赋值运算符右边的值，一般是一个具体的值**
  > 这是为了强调**_有些值不能放在赋值运算符的左边_**，比如 x = 1 是合法的表达式，但是 1 = x 就会报错

#### 5.作用域

- **_作用域 (scope ) 指的是变量生效的范围_**，C 语言的变量作用域主要有两种：**文件作用域 (file scope ) **和**块作用域 (block scope ) **
- 文件作用域 (file scope ) 指的是，**在源码文件顶层声明的变量，从声明的位置到文件结束都有效**

```c
#include <stdio.h>

int a = 0;

int main(){

    int b = a + 5;

    printf("%i",b);

    return 0;
}
```

> 变量 a 是在文件顶层声明的，从声明位置开始的整个当前文件都是它的作用域，可以在这个范围的任何地方读取这个变量，比如函数 main()内部就可以读取这个变量

- 块作用域 (block scope ) 指的是**_由大括号 { }组成的代码块，它形成一个单独的作用域，凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见_**

```c
int a = 3;

int main(){
    int b = a * 5;
    {
        int c = b + 5;

    }
    b = c;  // 错误

    return 0;
}
```

> 变量 c 只存在于代码块内，代码块以外是没有这个变量的

- **_代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域_**
- 它的规则是：**_内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量_**
  > 请注意，**函数里面的代码块和另一个函数里的局部变量不可相提并论**，下面这个在代码块里改变了 a 的值，那么 a 就是被改变了

```c
#include <stdio.h>

int main(){
    int a = 9;
    {
        a = 20;
        int b = a - 10;

        printf("%d\n",b);    // 10
        printf("%d\n",a);    // 20
    }

    printf("%d\n",a);        // 20
    return 0;
}
```

> 但是下面这个，在另一个函数里使用 a，函数结束 a 就被回收了，不会影响 main 里 a 的值 (在后面讲解指针的时候，可以打印出这两个 a 的地址，是不同的 )

```c
#include <stdio.h>

int add(int a){
    a++;
    printf("%d\n",a);
    return a;
}

int main(){
    int a = 10;

    printf("%d\n",a);

    add(a);

    printf("%d\n",a);

    return 0;
}
```

```c
#include <stdio.h>

int main(){
    int a = 9;
    {
        float a = 1.6;
        int b = 10;

        printf("%d\n",b);    // 10
        printf("%f\n",a);    // 1.600000
    }

    printf("%d\n",a);        // 9
    return 0;
}
```

> 但是请看这里，局部变量声明了一个跟 a 同名但不同类型的变量，出来后不发生变化，因此**_相同名称但不同类别的变量会创建一个同名变量，不影响原变量_**

- **_最常见的作用域就是函数_**，循环或判断，这些包含大括号的变量只在函数内发生影响

### 肆: 运算符

- 正如上面所说，运算符 (操作符 ) 用来控制数据进行计算，下面根据运算符的类型逐个介绍

#### 1.算术运算符

- **_算术运算符专门用于算术运算_**

| 符号 | 作用                     |
| ---- | ------------------------ |
| +    | 正值运算符 (一元运算符 ) |
| -    | 负值运算符 (一元运算符 ) |
| +    | 加法运算符 (二元运算符 ) |
| -    | 减法运算符 (二元运算符 ) |
| \*   | 乘法运算符               |
| /    | 除法运算符               |
| %    | 余值运算符               |

##### 1.1 \+ 和 \- (加和减 )

- +和-既可以作为一元运算符，也可以作为二元运算符。**_所谓"一元运算符"，指的是只需要一个运算数就可以执行_**，一元运算符 _-_ **_用来改变一个值的正负号_**

```c
a = -12;

a = -a;
```

- 一元运算符+对正负值没有影响，是一个完全可以省略的运算符，但是写了也不会报错

```c
b = -24;

b = +b;

// b = -24
```

- **_二元运算符+和-用来完成加法和减法_**

```c
y = 34 - 464;

x = y + 234;
```

##### 1.2 \* 乘号

- **_\* 用来进行乘法_**

```c
int n = 5;

int n_square = n * n;
```

##### 1.3 / 除号

- **_运算符/用来完成除法。注意，两个整数相除，得到还是一个整数_**

```c
int a = 10.0;
int b = 3;

float c = a / b;

// c = 1.0
```

> 尽管结果是小数，但是结果不会进行浮点运算，因为**_C 语言的整数除法是整除，不会保留小数部分_**

- **_如果想保留小数部分，除数中起码要有一个浮点数_**，这时便会进行浮点运算

```c
float x = 10.0 / 3;
```

- 请注意，**_C 语言是向零取整_**，比如 3 除以 4 是 0 而不是 0.75

```c
int x = 5;
int y = (x / 20) * 100;

// y = 0
```

> 因为 x 除以 20 是整除，0 乘 100 还是零，如果想要 25 可以写成 5.0 或 20.0

##### 1.4 % 取余

- 这里必须先说一下**_取余和取模的区别_**
  > a = c \* b + r (0 <= r <= b)  
  > 这是除法以及取余的定义

> 比如-10 / 3，根据定义，我们知道-10 = -3 \* 3 + (-1)，r = -1

> 再比如 10 / -3，10 = -3 \* -3 + 1，r = 1

- C 语言是向零取整，Python 是向负无穷取整，这就导致以下的问题
  > **Python 里-10 / 3 = -3.333··· = -4，-10 = -4 \* 3 + 2，r = 2 ？？？**  
  > **C 语言里-10 / 3 = -3.333··· = -3，-10 = -3 \* 3 + -1**
- 本质上因为所得*商*不同，而取整方式导致了商的不同，这里得到的两个不同的结果，我们称为*正余数*和*负余数*，当 ab 同号时取余取模没区别，但不同号时就有区别了
  > **取余：让商进行向 0 取整**  
  > **取模：让商进行向负无穷大取整**
- 所以%对负数取余时，**_结果的正负号由第一个运算数的正负号决定_**

```c
10 % 3 = 1;

// 正常情况

-10 % 3 = -1;
-10 % -3 = -1;
10 % -3 = 1;
```

- 那如果我就要四舍五入或者其他方法呢？**_有四个函数可以自定义取整方式 (注意要引入<math.h> )_**，传入一个小数
  > trunc() 向 0 取整，就是 C 的默认方式，所以用的很少  
  > floor() 向负无穷大取整  
  > celi() 向正无穷大取整  
  > round() 四舍五入
- 三者均返回一个浮点数

##### 1.5 简写运算

- 当变量对自身进行赋值运算时，可以简写将运算符和加号合并

```c
int x = 1;

x += 1;
x -= 2;
x *= 3;
x /= 4;
x %= 5;
```

#### 2.自增自减运算符

- 在介绍之前，我必须得说*这个自增自减特别容易弄错，强烈不建议使用这个，而且他也不符合 c 语言的一向习惯*
- **_C 语言有两个一元运算符，快速的进行自增自减运算_**
  > a++ 等同于 a += 1  
  > a - - 等同于 a -= 1
- **_这两个运算符放在变量的前面或后面，结果是不一样的_**

```c
int i = 10,j;

j = i++ + 10;

// j = 20;i = 11
```

> 分析：先返回自增之前的值与 10 相加后赋予 j，在进行 i += 1 (自增 )

```c
int i = 10,j;

j = ++i + 10;

// j = 21;i = 11
```

> 分析：先自增 (i += 1 ) ，再返回自己的值与 10 相加赋予 j

#### 3.关系运算符

- C 语言用于比较的表达式，称为"关系表达式" (relational expression ) ，**_关系表达式使用的运算符就称为"关系运算符" (relational operator )_**，主要有下面 6 个

| 符号 | 作用           |
| ---- | -------------- |
| >    | 大于运算符     |
| <    | 小于运算符     |
| >=   | 大于等于运算符 |
| <=   | 小于等于运算符 |
| ==   | 相等运算符     |
| !=   | 不相等运算符   |

```c
a > b;
a < b;
a >= b;
a <= b;
a == b;
a != b;
```

> **_请注意等于运算符 == 和赋值运算符 = 不同，切忌混淆_**

- **_关系表达式通常返回 0 或 1，表示真伪_** (没错 C 没有布尔值 ) C 语言中，0 表示伪，所有非零值表示真

```c
20 > 4;
>>> 1

20 < 4;
>>> 0
```

- 关系表达式常用于*if*或*while*结构，以后讲

```c
if (x == 9){
    printf("x is 9");
}
```

```c
// 如果将==写成=可能会导致一些问题

if (x = 8){
    return 0;
}

// 上面的 x = 8 给 x 赋值，同时返回 8，非零，所以会通过

if (8 == x){
    return 0;
}

// 这样把变量写到右边，如果少写一个等号就不会通过
```

> 可以将变量写在判断式的右边

- **_多个关系运算符不宜连用_**

```c
m < n < p < q

// 上面的运算并不一定会返回你想的结果，因为

(m < n) < p

// 由于是从左往右运算，比较 mn 返回的是一个 0 或 1 ，是拿 0 或 1 与 p 比较
```

#### 4.逻辑运算符

- **_逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式_**，主要有下面三个运算符

| 符号                                                                | 作用                                                   |
| ------------------------------------------------------------------- | ------------------------------------------------------ |
| !                                                                   | 否运算符 (改变单个表达式的真伪 )                       |
| &&                                                                  | 与运算符 (两侧的表达式都为真，则为真，否则为伪 )       |
| \| \|                                                               | 或运算符 (两侧至少有一个表达式为真，则为真，否则为伪 ) |
| > **_对于逻辑运算符来说，任何非零值都表示真，零值表示伪_**，比如，5 |                                                        | 0 会返回 1，5 && 0 会返回 0 |

- **_逻辑运算符还有一个特点，它总是先对左侧的表达式求值，再对右边的表达式求值_**，这个顺序是保证的，**_如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值_**，这种情况称为**短路**

```c
if (number != 0 && 12/number == 2)

// 上面先对左侧判断，如果为假  (即number为0 ) ，就不会判断右侧的表达式，也不会报错了

if ((x++ < 10) && (x + y < 20))

// 由于是先左后右，上面的在执行过左面表达式后 x 的值已经变了，再去执行右边时往往不是我们想要的值
```

- 运用逻辑运算符我们可以让上面的多关系表达式作用

```c
m < n && n < p && p < q

// 只有上面三个同时成立才行
```

#### 5.位运算符

- C 语言提供一些**_位运算符，用来操作二进制位 (bit )_**

##### 5.1 取反运算符 ~

- **_取反运算符～是一个一元运算符，用来将每一个二进制位变成相反值_**，即 0 变成 1，1 变成 0

```c
~ 10001010

// 返回 01110101
```

> 他只是返回，**不会改变原值**

##### 5.2 与运算符 &

- **_与运算符 & 将两个值的每一个二进制位进行比较，返回一个新的值_**，当两个二进制位都为 1，就返回 1，否则返回 0

```c
01001100 & 10010010

// 返回 00000000
```

- **_与运算符 & 可以与赋值运算符 = 结合，简写成 &=_**

```c
int num = 53;

num = num & 213;

// 等于

num &= 213;
```

##### 5.3 或运算符 |

- **_或运算符 | 将两个值的每一个二进制位进行比较，返回一个新的值，两个二进制位只要有一个为 1 (包含两个都为 1 的情况 ) ，就返回 1，否则返回 0_**
  > **同样可以与 = 简写为 |=**

##### 5.4 异或运算符 ^

- **_异或运算符 ^ 将两个值的每一个二进制位进行比较，返回一个新的值，两个二进制位有且仅有一个为 1，就返回 1，否则返回 0_**
  > **与 = 简写为 ^=**

##### 5.5 左移运算符 <<

- **_左移运算符<<将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用 0 填充_**

```c
01011111 << 2

// 返回 0101111100
```

- **左移运算符相当于将运算数乘以 2 的指定次方**，比如左移 2 位相当于乘以 4 (2 的 2 次方 )

```c
int num = 45;

num = num << 2;

// 等于

num <<= 2;
```

> **可以与 = 简写为 <<=**

##### 5.6 右移运算符 >>

- **_右移运算符>>将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用 0 填充_**

```c
10100111 >> 2

// 返回 00101001
// 末尾两位被抛弃，头两位用00填充
```

- 注意，**右移运算符最好只用于无符号整数**，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果
- **右移运算符相当于将运算数除以 2 的指定次方**，比如右移 2 位就相当于除以 4 (2 的 2 次方 )

```c
int num = 45;

num = num >> 2;

// 等于

num >>= 2;
```

> **可以与 = 连写为 >>=**

#### 6.逗号运算符

- **_逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式_**

```c
x += 3,y -= 4,z ^= 89;
```

- **_逗号运算符返回最后一个表达式的值，作为整个语句的值_**

```c
int num;

num = (4 + 3,8 * 9,0 - 2);

// num = -2
```

#### 7.运算优先级

- **_优先级指的是，如果一个表达式包含多个运算符，哪个运算符应该优先执行_**，各种运算符的优先级是不一样的

```c
int num;

num = 3 + 5 * 0;

// 先计算乘法，再计算加法
// num = 3
```

- 如果两个运算符优先级相同，则根据运算符**_是左结合，还是右结合，决定执行顺序_**。大部分运算符是左结合 (从左到右执行 ) ，**少数运算符是右结合 (从右到左执行 ) ，比如赋值运算符 (= ) **

```c
int num;

num = 9 * 9 / 9

// 同级运算从左至右
```

- 下面是一些运算符的优先级，优先级从上至下
  > **圆括号 ( )**  
  > **自增运算符 + + ，自减运算符 - -**  
  > **一元运算符 + 和 -**  
  > **乘法 \* ，除法 /**  
  > **加法 + ，减法 -**  
  > **关系运算符 < ，> 等**  
  > **赋值运算符 =**

```c
int num;

num = (5 + 6) * 0;
```

> 完全记住所有运算符的优先级没有必要，解决方法是**多用圆括号，它的优先级最高**，防止出现意料之外的情况，也有利于提高代码的可读性

### 伍: 数据类型

- **_C 语言的每一种数据，都是有类型 (type ) 的_**，编译器必须知道数据的类型，才能操作数据。所谓"类型"，就是相似的数据所拥有的共同特征，那么一旦知道某个值的数据类型，就能知道该值的特征和操作方式
- 基本数据类型有三种：字符 (char ) 、整数 (int ) 和浮点数 (float ) 。复杂的类型都是基于它们构建的

#### 1.字节

- 在介绍数据类型之前，我们先介绍下数据是如何存储的
- **计算机里的一切都是 0101001 的方式存储的，一个 0 或 1 就是 1 位 (bite，binary digit 的简写或者比特 ) ，一个比特只能存储两种状态，0 和 1**
  > 一位 0 1
- 两位，三位比特，**_随着比特数的增加，存储空间变大同时表达的状态也变多了_**
  > 两位 00 01 10 11  
  > 三位 000 001 010 011 100 101 110 111  
  > 位数增加，状态分别为 2，4，8
- 如果只用比特衡量，随着数据的变大就太好表示了，所以**_一字节 (Byte ) 等于八字节_**，能表达的状态从 00000000 到 11111111
  > 我们现在常见的 GB，TB 就是 GigaByte，TeraByte 的简写，常用于下载速度的 KiB，MiB 就是 Kilobite，Megabite 的简写
- **_字_**，**在计算机中，一串数码作为一个整体来处理或运算的，称为一个计算机字**，简称*宇*。字**通常分为若干个字节**(每个字节一般是 8 位)。在存储器中，_通常每个单元存储一个字，因此每个字都是可以寻址的_。字的*长度用位数来表示*。
  在计算机的运算器、控制器中，通常都是以字为单位进行传送的。**宇出现在不问的地址其含义是不相同**。例如，_送往控制器去的字是指令_，_而送往运算器去的字就是一个数_。
  在计算机中**作为一个整体被存取、传送、处理的二进制数字符串叫做一个字或单元**，**_每个字中二进制位数的长度，称为字长_**。一个字由若干个字节组成，不同的计算机系统的字长是不同的，常见的有 8 位、16 位、32 位、64 位等，字长越长，计算机一次处理的信息位就越多，精度就越高，字长是计算机性能的一个重要指标。目前主流微机都是 64 位机。
  注意字与字长的区别，字是单位，而字长是指标，指标需要用单位去衡量。正象生活中重量与公斤的关系，公斤是单位，重量是指标，重量需要用公斤加以衡量
- 计算机的每个字所包含的位数称为字长。根据计算机的不同，**_字长有固定的和可变的两种_**。固定字长，即**字长度不论什么情况都是固定不变的**；可变字长，**则在一定范围内，其长度是可变的**。
  计算的字长是指它一次可处理的二进创数字的数目。计算机处理数据的速率，自然和它一次能加工的位数以及进行运算的快慢有关。如果一台计算机的字长是另一台计算机的两倍，即使两台计算机的速度相同，在相同的时间内，前者能做的工作是后者的两倍。
  一般地，大型计算机的字长为 32―64 位，小型计算机为 12―32 位，而微型计算机为 4 一 16 位。字长是衡量计算机性能的一个重要因素
  > 上面是复制粘贴来的一段废话，看看得了

#### 2.字符

- **_字符类型指的是单个字符，类型声明使用 char 关键字_**
- **_字符量必须放在单引号里面_**
  > 绝对注意，**是单个字符，不是单词**

```c
char a = 'A'
```

- **_在计算机内部，字符类型使用一个字节 (8 位 ) 存储_**。C 语言将其当作整数处理，所以**_字符类型就是宽度为一个字节的整数_**。每个字符对应一个整数 (由 ASCII 码确定 ) ，比如 A 对应整数 65
- 下面附上 _ASCII 编码一览表_，方便查阅
  > 字符类型在不同计算机的默认范围是不一样的。一些系统默认为-128 到 127，另一些系统默认为 0 到 255。这两种范围正好都能覆盖 0 到 127 的 ASCII 字符范围  
  > 为什么不是-128 到 128？零也占一位

| 二进制   | 十进制 | 十六进制 | 字符/缩写                                   | 解释                               |
| -------- | ------ | -------- | ------------------------------------------- | ---------------------------------- |
| 00000000 | 0      | 00       | NUL (NULL)                                  | 空字符                             |
| 00000001 | 1      | 01       | SOH (Start Of Headling)                     | 标题开始                           |
| 00000010 | 2      | 02       | STX (Start Of Text)                         | 正文开始                           |
| 00000011 | 3      | 03       | ETX (End Of Text)                           | 正文结束                           |
| 00000100 | 4      | 04       | EOT (End Of Transmission)                   | 传输结束                           |
| 00000101 | 5      | 05       | ENQ (Enquiry)                               | 请求                               |
| 00000110 | 6      | 06       | ACK (Acknowledge)                           | 回应/响应/收到通知                 |
| 00000111 | 7      | 07       | BEL (Bell)                                  | 响铃                               |
| 00001000 | 8      | 08       | BS (Backspace)                              | 退格                               |
| 00001001 | 9      | 09       | HT (Horizontal Tab)                         | 水平制表符                         |
| 00001010 | 10     | 0A       | LF/NL(Line Feed/New Line)                   | 换行键                             |
| 00001011 | 11     | 0B       | VT (Vertical Tab)                           | 垂直制表符                         |
| 00001100 | 12     | 0C       | FF/NP (Form Feed/New Page)                  | 换页键                             |
| 00001101 | 13     | 0D       | CR (Carriage Return)                        | 回车键                             |
| 00001110 | 14     | 0E       | SO (Shift Out)                              | 不用切换                           |
| 00001111 | 15     | 0F       | SI (Shift In)                               | 启用切换                           |
| 00010000 | 16     | 10       | DLE (Data Link Escape)                      | 数据链路转义                       |
| 00010001 | 17     | 11       | DC1/XON (Device Control 1/Transmission On)  | 设备控制 1/传输开始                |
| 00010010 | 18     | 12       | DC2 (Device Control 2)                      | 设备控制 2                         |
| 00010011 | 19     | 13       | DC3/XOFF(Device Control 3/Transmission Off) | 设备控制 3/传输中断                |
| 00010100 | 20     | 14       | DC4 (Device Control 4)                      | 设备控制 4                         |
| 00010101 | 21     | 15       | NAK (Negative Acknowledge)                  | 无响应/非正常响应/拒绝接收         |
| 00010110 | 22     | 16       | SYN (Synchronous Idle)                      | 同步空闲                           |
| 00010111 | 23     | 17       | ETB (End of Transmission Block)             | 传输块结束/块传输终止              |
| 00011000 | 24     | 18       | CAN (Cancel)                                | 取消                               |
| 00011001 | 25     | 19       | EM (End of Medium)                          | 已到介质末端/介质存储已满/介质中断 |
| 00011010 | 26     | 1A       | SUB (Substitute)                            | 替补/替换                          |
| 00011011 | 27     | 1B       | ESC (Escape)                                | 逃离/取消                          |
| 00011100 | 28     | 1C       | FS (File Separator)                         | 文件分割符                         |
| 00011101 | 29     | 1D       | GS (Group Separator)                        | 组分隔符/分组符                    |
| 00011110 | 30     | 1E       | RS (Record Separator)                       | 记录分离符                         |
| 00011111 | 31     | 1F       | US (Unit Separator)                         | 单元分隔符                         |
| 00100000 | 32     | 20       | (Space)                                     | 空格                               |
| 00100001 | 33     | 21       | !                                           |
| 00100010 | 34     | 22       | "                                           |
| 00100011 | 35     | 23       | #                                           |
| 00100100 | 36     | 24       | \$                                          |
| 00100101 | 37     | 25       | %                                           |
| 00100110 | 38     | 26       | &                                           |
| 00100111 | 39     | 27       | '                                           |
| 00101000 | 40     | 28       | (                                           |
| 00101001 | 41     | 29       | )                                           |
| 00101010 | 42     | 2A       | \*                                          |
| 00101011 | 43     | 2B       | +                                           |
| 00101100 | 44     | 2C       | ,                                           |
| 00101101 | 45     | 2D       | -                                           |
| 00101110 | 46     | 2E       | .                                           |
| 00101111 | 47     | 2F       | /                                           |
| 00110000 | 48     | 30       | 0                                           |
| 00110001 | 49     | 31       | 1                                           |
| 00110010 | 50     | 32       | 2                                           |
| 00110011 | 51     | 33       | 3                                           |
| 00110100 | 52     | 34       | 4                                           |
| 00110101 | 53     | 35       | 5                                           |
| 00110110 | 54     | 36       | 6                                           |
| 00110111 | 55     | 37       | 7                                           |
| 00111000 | 56     | 38       | 8                                           |
| 00111001 | 57     | 39       | 9                                           |
| 00111010 | 58     | 3A       | :                                           |
| 00111011 | 59     | 3B       | ;                                           |
| 00111100 | 60     | 3C       | <                                           |
| 00111101 | 61     | 3D       | =                                           |
| 00111110 | 62     | 3E       | >                                           |
| 00111111 | 63     | 3F       | ?                                           |
| 01000000 | 64     | 40       | @                                           |
| 01000001 | 65     | 41       | A                                           |
| 01000010 | 66     | 42       | B                                           |
| 01000011 | 67     | 43       | C                                           |
| 01000100 | 68     | 44       | D                                           |
| 01000101 | 69     | 45       | E                                           |
| 01000110 | 70     | 46       | F                                           |
| 01000111 | 71     | 47       | G                                           |
| 01001000 | 72     | 48       | H                                           |
| 01001001 | 73     | 49       | I                                           |
| 01001010 | 74     | 4A       | J                                           |
| 01001011 | 75     | 4B       | K                                           |
| 01001100 | 76     | 4C       | L                                           |
| 01001101 | 77     | 4D       | M                                           |
| 01001110 | 78     | 4E       | N                                           |
| 01001111 | 79     | 4F       | O                                           |
| 01010000 | 80     | 50       | P                                           |
| 01010001 | 81     | 51       | Q                                           |
| 01010010 | 82     | 52       | R                                           |
| 01010011 | 83     | 53       | S                                           |
| 01010100 | 84     | 54       | T                                           |
| 01010101 | 85     | 55       | U                                           |
| 01010110 | 86     | 56       | V                                           |
| 01010111 | 87     | 57       | W                                           |
| 01011000 | 88     | 58       | X                                           |
| 01011001 | 89     | 59       | Y                                           |
| 01011010 | 90     | 5A       | Z                                           |
| 01011011 | 91     | 5B       | [                                           |
| 01011100 | 92     | 5C       | \|                                          |
| 01011101 | 93     | 5D       | ]                                           |
| 01011110 | 94     | 5E       | ^                                           |
| 01011111 | 95     | 5F       | \_                                          |
| 01100000 | 96     | 60       | `                                           |
| 01100001 | 97     | 61       | a                                           |
| 01100010 | 98     | 62       | b                                           |
| 01100011 | 99     | 63       | c                                           |
| 01100100 | 100    | 64       | d                                           |
| 01100101 | 101    | 65       | e                                           |
| 01100110 | 102    | 66       | f                                           |
| 01100111 | 103    | 67       | g                                           |
| 01101000 | 104    | 68       | h                                           |
| 01101001 | 105    | 69       | i                                           |
| 01101010 | 106    | 6A       | j                                           |
| 01101011 | 107    | 6B       | k                                           |
| 01101100 | 108    | 6C       | l                                           |
| 01101101 | 109    | 6D       | m                                           |
| 01101110 | 110    | 6E       | n                                           |
| 01101111 | 111    | 6F       | o                                           |
| 01110000 | 112    | 70       | p                                           |
| 01110001 | 113    | 71       | q                                           |
| 01110010 | 114    | 72       | r                                           |
| 01110011 | 115    | 73       | s                                           |
| 01110100 | 116    | 74       | t                                           |
| 01110101 | 117    | 75       | u                                           |
| 01110110 | 118    | 76       | v                                           |
| 01110111 | 119    | 77       | w                                           |
| 01111000 | 120    | 78       | x                                           |
| 01111001 | 121    | 79       | y                                           |
| 01111010 | 122    | 7A       | z                                           |
| 01111011 | 123    | 7B       | {                                           |
| 01111100 | 124    | 7C       | \|                                          |
| 01111101 | 125    | 7D       | }                                           |
| 01111110 | 126    | 7E       | ~                                           |
| 01111111 | 127    | 7F       | DEL (Delete)删除                            |

- 只要在字符类型的范围之内，**_整数与字符是可以互换的_**，都可以赋值给字符类型的变量

```c
char a = 65;

// 等同于

char a = 'A';
```

- 同样，**字符变量也可以互相加减**

```c
char a = 65,b = 66;

int x = a + b;

// x = 131
```

> 单引号本身也是一个字符，如果要表示这个字符常量，必须使用**反斜杠转义**

```c
char c = '\'';
```

- 这种**_转义的写法，主要用来表示 ASCII 码定义的一些无法打印的控制字符，它们也属于字符类型的值_**
  > \a：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生  
  > \b：退格键，光标回退一个字符，但不删除字符  
  > \f：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于\v  
  > \n：换行符  
  > \r：回车符，光标移到同一行的开头  
  > \t：制表符，光标移到下一个水平制表位，通常是下一个 8 的倍数  
  > \v：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列  
  > \0：null 字符，代表没有内容。注意，这个值不等于数字 0
- 转义写法还能使用八进制和十六进制表示一个字符
  > \nn：字符的八进制写法，nn 为八进制值  
  > \xnn：字符的十六进制写法，nn 为十六进制值

```c
char d = 'D';
char d = 68;
char d = '/104';    // 68的八进制
char d = '/x44';    // 68的十六进制

// 上文四种写法意义相同
```

- 这里附转换方式
  > 不得不感叹人类的伟大，将量的概念抽象出来，不同地区的独立发展，最后又是那么的相像。所以数字，其实就是符号对数量的映射，并且人们达成了共识
- 我们知道，进制的意义如下
  > ··· a _ 10^3 + b _ 10^2 + c _ 10^1 + d _ 10^0 + e _ 10^-1 + f _ 10^-2  
  > 2024.1 = 2 _ 1000 + 0 _ 100 + 2 _ 10 + 4 _ 1 + 1 \* 0.1
- 那么对于进制不同的表达方式同理
  > 101 = 1 _ 2^2 + 0 _ 2^1 + 1 \* 2^0 = 4 + 0 + 1 = 5  
  > 这就是如何将其他进制转换为十进制，不同进制只是底数不同
- 那么如何将十进制转换为二进制？
  > 比如 2023 转换为二进制，我们知道 2023 可以这样写  
  > ··· a _ 2^4 + b _ 2^3 + c _ 2^2 + d _ 2^1 = 2023  
  > 同时除以 2  
  > ··· a _ 2^3 + b _ 2^2 + c _ 2^1 + d / 2 = 2022 / 2 + 0 / 2  
  > 这不就可以把 d 看作 1 吗？我们还可以把能整除的部分继续下去  
  > ··· a _ 2^2 + b \* 2^1 + c / 2 = 1011 / 2 = 1010 / 2 + 1 / 2  
  > 我们一直持续这个过程就可以把 a，b，c 都求出来
- 这就是*求余转换*
  > 2 | 2022  
  >  2 | 1011 ----- 0  
  >  2 | 505 ----- 1  
  >  2 | 252 ----- 1  
  >  2 | 126 ----- 0  
  > ···我挑了一个太大的数 😅
- 那小数怎么办？用乘法
  > 0.602，我们知道等于  
  > e _ 2^-1 + f _ 2^-2 + g _ 2^-3 = 0.602  
  > 同时乘 2  
  > e _ 1 + f _ 2^-1 + g _ 2^-2 = 1.204 = 1 + 0.204  
  > e 不就等于 1 吗？  
  > 但是由于二进制的小数是 0.5，0.25，0.125 这种构成的，很少能构成十进制的小数，所以看你的需要的精度了，甚至 0.1 的二进制都是一个无限循环小数

#### 3.整数

##### 3.1 int

- **_整数类型用来表示较大的整数，类型声明使用 int 关键字_**

```c
int a;

// 声明a是一个整数
```

- **不同计算机的 int 类型的大小是不一样的**。比较常见的是使用 4 个字节 (32 位 ) 存储一个 int 类型的值，但是 2 个字节 (16 位 ) 或 8 个字节 (64 位 ) 也有可能使用。它们可以表示的整数范围如下
  > 16 位：-32,768 到 32,767  
  > 32 位：-2,147,483,648 到 2,147,483,647  
  > 64 位：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
- 没错，如果你**_设置一个比上面的整数还大的整数，是编译不了的，会溢出_**

##### 3.2 signed

- C 语言**_使用 signed 关键字，表示一个类型带有正负号，包含负值；使用 unsigned 关键字，表示该类型不带有正负号，只能表示零和正整数_**
- 对于 int 类型，**默认是带有正负号的**，也就是说 int 等同于 signed int。由于这是默认情况，关键字 signed 一般都省略不写，但是写了也不算错

```c
signed int a;

// 等于

signed a;

// 等于

int a;
```

> 也可以不写 int，直接表示

- int 类型也可以不带正负号，只表示非负整数。这时就必须**使用关键字 unsigned 声明变量**

```c
unsigned int a;
```

- **整数变量声明为 unsigned 的好处是，同样长度的内存能够表示的最大整数值，增大了一倍**。比如，16 位的 signed int 最大值为 32,767，而 unsigned int 的最大值增大到了 65,535
  > 同样也可以不写 int

```c
unsigned a;
```

- **_字符类型 char 也可以设置 signed 和 unsigned_**

```c
signed char a; //  -128 到 127
unsigned char a; //  0 到 255
```

- **_注意，C 语言规定 char 类型默认是否带有正负号，由当前系统决定_**。这就是说，char 不等同于 signed char，它有可能是 signed char，也有可能是 unsigned char。这一点与 int 不同，int 就是等同于 signed int

##### 3.3 short 和 long

- 如果 int 类型使用 4 个或 8 个字节表示一个整数，**对于小整数，这样做很浪费空间**。另一方面，**某些场合需要更大的整数，8 个字节还不够**。为了解决这些问题，**_C 语言在 int 类型之外，又提供了三个整数的子类型_**。这样有利于更精细地限定整数变量的范围，也有利于更好地表达代码的意图

```c
short int = a;
long int = a;
long long int a;

// 同样可以不加int
```

> **short int (简写为 short ) ：占用空间不多于 int，一般占用 2 个字节 (整数范围为-32768 ～ 32767 )**

> **long int (简写为 long ) ：占用空间不少于 int，至少为 4 个字节**  
> **long long int (简写为 long long ) ：占用空间多于 long，至少为 8 个字节**

- 默认情况下，short、long、long long 都是带符号的 (signed ) ，即 signed 关键字省略了。**_它们也可以声明为不带符号 (unsigned ) ，使得能够表示的最大值扩大一倍_**

```c
unsigned short int = a;
unsigned long int = a;
unsigned long long int = a;

// 当然也等于

unsigned short = b;
unsigned long = b;
unsigned long long = b;

// 即使是这样，也有一些数字是C语言表达不了的
```

> 不同的计算机，数据类型的字节长度是不一样的。确实需要 32 位整数时，应使用 long 类型而不是 int 类型，可以确保不少于 4 个字节；确实需要 64 位的整数时，应该使用 long long 类型，可以确保不少于 8 个字节。另一方面，为了节省空间，只需要 16 位整数时，应使用 short 类型；需要 8 位整数时，应该使用 char 类型

##### 3.4 极限

- 有时候需要查看，当前系统不同整数类型的最大值和最小值，**_C 语言的头文件 limits.h 提供了相应的常量_**
  > 为了代码的可移植性，**_需要知道某种整数类型的极限值时，应该尽量使用这些常量_**

| 名称                 | 作用                         |
| -------------------- | ---------------------------- |
| SCHAR_MIN，SCHAR_MAX | signed char 的最小值和最大值 |
| SHRT_MIN，SHRT_MAX   | short 的最小值和最大值       |
| INT_MIN，INT_MAX     | int 的最小值和最大值         |
| LONG_MIN，LONG_MAX   | long 的最小值和最大值        |
| LLONG_MIN，LLONG_MAX | long long 的最小值和最大值   |
| UCHAR_MAX            | unsigned char 的最大值       |
| USHRT_MAX            | unsigned short 的最大值      |
| UINT_MAX             | unsigned int 的最大值        |
| ULONG_MAX            | unsigned long 的最大值       |
| ULLONG_MAX           | unsigned long long 的最大值  |

```c
#include <stdio.h>
#include <limits.h>

int main(){
    printf("%llu\n",ULLONG_MAX);
    return 0;
}

>>> 18446744073709551615

// 你没看错，这就是C语言的极限，unsigned long long 只能表达到这里
// 2^64 = 18446744073709551616，基本相同
```

##### 3.5 进制

- **_C 语言的整数默认都是十进制数，如果要表示八进制数和十六进制数，必须使用专门的表示法_**
- **八进制使用 0 作为前缀**，比如 017、0377

```c
int a = 012; // 八进制，相当于十进制的10
```

- **十六进制使用 0x 或 0X 作为前缀**，比如 0xf、0X10

```c
int a = 0x1A2B; // 十六进制，相当于十进制的6699
```

- 有些编译器**使用 0b 前缀，表示二进制数**，但不是标准

```c
int x = 0b101010;
```

> 注意，**不同的进制只是整数的书写方法，不会对整数的实际存储方式产生影响**。所有整数都是二进制形式存储，跟书写方式无关。不同进制可以混合使用，比如 10 + 015 + 0x20 是一个合法的表达式

- printf()的进制相关占位符如下
  > %d：十进制整数  
  > %o：八进制整数  
  > %x：十六进制整数  
  > %#o：显示前缀 0 的八进制整数  
  > %#x：显示前缀 0x 的十六进制整数  
  > %#X：显示前缀 0X 的十六进制整数

```c
int x = 100;
printf("dec = %d\n", x); // 100
printf("octal = %o\n", x); // 144
printf("hex = %x\n", x); // 64
printf("octal = %#o\n", x); // 0144
printf("hex = %#x\n", x); // 0x64
printf("hex = %#X\n", x); // 0X64
```

##### 3.6 sizeof()函数

- **_如果不确定哪个类型具体的占用空间，可以用 sizeof 函数，返回占用字节数_**

```c
#include <stdio.h>

int main(){
    printf("int: %d\n",sizeof(int));
    printf("char: %d\n",sizeof(char));

    return 0;
}
```

#### 4.浮点数

- **_任何有小数点的数值，都会被编译器解释为浮点数。所谓"浮点数"就是使用 m _ b^e 的形式，存储一个数值\***，m 是小数部分，b 是基数 (通常是 2 ) ，e 是指数部分。这种形式是精度和数值范围的一种结合，可以表示非常大或者非常小的数
- **_浮点数的类型声明使用 float 关键字，可以用来声明浮点数变量_**

```c
float a = 1.22;
```

- **_float 在内存中占 4 字节 (32 位)，第一位是符号位 (sign ) ，符号位后面 8 位是指数位 (exponent ) ，最后 23 位是尾数 (mantissa )_**
  > 对于指数部分，因为指数可正可负，8 位的指数位能表示的指数范围就应该为:-127 ~ 128 了，所以指数部分的存储采用移位存储，存储的数据为原数据+127
- 现在使用的是**IEEE - 754 浮点数标准**，可以看[这个网站](https://www.h-schmidt.net/FloatConverter/IEEE754.html)关于详细的转换
  > 比如 111.125，二进制等于 1101111.001 _ 10^0，等于 1.101111001 _ 10^6  
  > 0.125，等于 0.001 _ 10^0，等于 1 _ 10^-3
- 可以看到，由于位数开头一定是 1.···，所以**那个整数部分的 1 其实是不用存储的**
  > 那么怎么表示零，特殊规定**当底数指数全为零时这个小数就是零，0.00000**
- 还需要注意一件事，如同上文所说，**_有一些小数是二进制怎么也表达不了的，那么想当然的对浮点数的运算结果做判断是会出错的，请注意精度_**

```c
x = (0.1 + 0.2 == 0.3);

// x = 0，即 0.1 + 0.2 不等于 0.3
```

- 四个字节可能不够我们使用，还有两种子类型
  > **_double：占用 8 个字节 (64 位 ) ，至少提供 13 位有效数字_**  
  > **_long double：通常占用 16 个字节_**
- **_C 允许使用科学计数法来表示小数_**

```c
int float x = 1.618e3;
int float x = 1.618e+3;
```

> 上面示例中，e 后面如果是加号+，加号可以省略  
> **_注意，科学计数法里面 e 的前后，不能存在空格_**  
> 另外，科学计数法的小数部分如果是 0.x 或 x.0 的形式，那么 0 可以省略

```c
0.3E6
// 等同于
.3E6

3.0E6
// 等同于
3.E6
```

#### 5.布尔值

- **C 语言 y 原生并没有布尔值**，而是使用**_整数 0_**和**_所有非零值_**来代表**_false 和 true_**

```c
int x = 1;
if (x) {
  printf("x is true!\n");
}

// if 认为 x 非零，于是执行语句块
```

- **_C99 标准添加了类型\_Bool，表示布尔值_**
  > 但是，这个类型其实只是整数类型的别名，还是使用 0 表示伪，1 表示真，下面是一个示例

```c
#include <stdio.h>

int main(){
    _Bool x = -90901;

    printf("%d",x);

    return 0;
}

// x 非零即为一
```

> 很奇怪 vscoe 竟然没有这个\_Bool 的自动补全？但是编译器支持就行

- **_头文件 <stdbool.h> 定义了另一个类型别名 bool，并且定义了 true 代表 1，false 代表 0_**

```c
#include <stdio.h>
#include <stdbool.h>

int main(){
    bool x = true;

    printf("%d",x);
    return 0;
}
```

#### 6.字面量

- **_字面量 (literal ) 指的是代码里面直接出现的值_**

```c
char a = 'U'

// a是变量，U就是字面量
```

> 你可以理解为**右值**

- 编译时，**_字面量也会写入内存，因此编译器必须为字面量指定数据类型_**，就像必须为变量指定数据类型一样。
  > 一般情况下，**_十进制整数字面量 (比如 123 ) 会从 int 开始一步步分配_**，如果 int 不够就用 long，long 不够 long long···  
  > **小数 (比如 3.14 ) 会被指定为 double 类型**
- 有些时候我们**_希望指定一个数据的类型，不希望编译器自动推算，就可以在字面量后面加上后缀_**
- 常用的后缀：
  > **f 和 F**：float 类型  
  > **l 和 L**：对于整数是 long int 类型，对于小数是 long double 类型  
  > **ll 和 LL**：Long Long 类型，比如 3LL  
  > **u 和 U**：表示 unsigned int，比如 15U、0377U
- 虽然大小写不分，但**_建议大写因为小写的 l 可能与 1 太像_**
- 请注意，**_字面的类型指定了不代表也把变量的类型指定了_**，比如

```c
int m = 18446744073709551615ULL;

// 编译器会报错，因为llu转换至i溢出了
// 你只是把字面量的类型指定了，m还是4字节的int
```

> 一定注意字面量和变量的概念

- **八进制和十六进制的值**，也可以使用后缀 l 和 L 指定为 Long 类型，比如 020L 和 0x20L

```c
int y = 0377L;
int z = 0x7fffL;
```

- **L 和 U 可以结合使用**，表示 unsigned long 类型，**L 和 U 的大小写和组合顺序无所谓**

```c
unsigned long long int x = 18446744073709551615ULL;

// 等于

unsigned long long int x = 18446744073709551615LLU;

// 但是请不要这样写，会报错

unsigned long long int x = 18446744073709551615LUL;
```

- 对于浮点数，编译器默认指定为 double 类型，如果希望指定为其他类型，需要在小数后面**添加后缀 f (float ) 或 l (long double ) **
- **科学计数法表示的小数也可以加上后缀**
- 以下便是字面量使用后缀 (为啥 short 没有？ )

```c
int           x = 1234;
long int      x = 1234L;
long long int x = 1234LL

unsigned int           x = 1234U;
unsigned long int      x = 1234UL;
unsigned long long int x = 1234ULL;

float x       = 3.14f;
double x      = 3.14;
long double x = 3.14L;
```

#### 7.溢出

- **_每一种数据类型都有数值范围，如果存放的数值超出了这个范围_** (小于最小值或大于最大值 ) ，需要更多的二进制位存储，就会发生溢出。**大于最大值，叫做向上溢出 (overflow ) **；**小于最小值，叫做向下溢出 (underflow ) **
- 一般来说，**编译器不会对溢出报错，会正常执行代码**，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。**所以，应该避免溢出** (废话 )

```c
#include <stdio.h>

int main(){
    char b = 127;
    printf("%d\n",b);

    b += 1;
    printf("%d\n",b);

    return 0;
}

// 一次输出127，对于char这就是最大值，所以加一以后变成了-128
// 最高位其实是进一了，但是被抛弃了，剩下的就是00000000最小值
```

> 这个高位溢出之后是可以补回来的

```c
#include <stdio.h>

int main(){
    char b = 127;
    printf("%d\n",b);

    b += 1;
    printf("%d\n",b);

    b--;
    printf("%d",b);
    return 0;
}

>>> 127
>>> -128
>>> 127
```

- **_溢出很容易被忽视，编译器又不会报错 (但是也能用来做一些奇技淫巧 ) ，所以必须非常小心_**

```c
for (unsigned int i = n; i >= 0; --i) // 错误

/*
上面代码表面看似乎没有问题，但是循环变量i的类型是 unsigned int，这个类型的最小值是0，不可能得到小于0的结果。当i等于0，再减去1的时候，并不会返回-1，而是返回 unsigned int 的类型最大值，这个值总是大于等于0，导致无限循环
*/

// 这里还没学，循环学完了记得回来看一眼
```

- 为了避免溢出，最好方法就是**_将运算结果与类型的极限值进行比较_**

```c
unsigned int ui;
unsigned int sum;

// 错误
if (sum + ui > UINT_MAX) too_big();
else sum = sum + ui;

// 正确
if (ui > UINT_MAX - sum) too_big();
else sum = sum + ui;
```

- 上面示例中，变量 sum 和 ui 都是 unsigned int 类型，它们相加的和还是 unsigned int 类型，这就有可能发生溢出。但是，**_不能通过相加的和是否超出了最大值 UINT_MAX，来判断是否发生了溢出_**，因为 sum + ui 总是返回溢出后的结果，不可能大于 UINT_MAX。**_正确的比较方法是，判断 UINT_MAX - sum 与 ui 之间的大小关系_**

```c
unsigned int j = 7;

if (i - j < 0) // 错误
  printf("negative\n");
else
  printf("positive\n");
```

> 上面示例的运算结果，会输出 positive。原因是变量 i 和 j 都是 unsigned int 类型，i - j 的结果也是这个类型，最小值为 0，不可能得到小于 0 的结果。正确的写法是写成下面这样

```c
if (j > i)
```

#### 8.sizeof ( )

- **_重要的事情说三遍，sizeof 是运算符，运算符，运算符，不是函数_**
- **_sizeof 是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量_**。它的参数可以是**数据类型的关键字**，也可以是**变量名或某个具体的值**

```c
printf("%d\n",sizeof(int));

int i = 9;
printf("%d\n",sizeof(i));

printf("%d\n",sizeof(9));

// 输出均为 4
```

- 因为 sizeof 不是函数，所以**_括号内的赋值和函数, 不会被执行_**

```c
char c=8;
int  i=32;
printf("%ld", sizeof(c    ));  // 结果:1, 因为char就是1字节
printf("%ld", sizeof(c+i  ));  // 结果:4, i是4字节, 运算时c值被隐式转换成int, 运算值是4字节
printf("%ld", sizeof(c=c+i));  // 结果:1, 等同于(c), 编译时, 因为=不被执行, 所以=的右边只是个屁
```

- 挺有意思的一个事情

```c
char c = 'c';

printf("%d\n",sizeof(c));

// 1字节，这个我们知道

printf("%d\n",sizeof('c'));

// C99：'c'是一个字符常量，字符字面量类型是 int，实际上按照整数来存储，只是他名字叫字符，所以占4字节  (字符串字面量按char来存储，见后文 )
// C++：'c'是一个字符字面量，看作char，1字节
```

- **_sizeof 运算符的返回值，C 语言只规定是无符号整数，并没有规定具体的类型，而是留给系统自己去决定_**，sizeof 到底返回什么类型。不同的系统中，返回值的类型有可能是 unsigned int，也有可能是 unsigned long，甚至是 unsigned long long，对应的 printf()占位符分别是%u、%lu 和%llu。这样不利于程序的可移植性
- C 语言提供了一个解决方法，创造了一个**_类型别名 size_t，用来统一表示 sizeof 的返回值类型_**。该别名定义在 stddef.h 头文件 (引入 stdio.h 时会自动引入 ) 里面，对应当前系统的 sizeof 的返回值类型，可能是 unsigned int，也可能是 unsigned long
- C 语言还提供了一个常量 SIZE_MAX，表示 size_t 可以表示的最大整数。所以，size_t 能够表示的整数范围为[0, SIZE_MAX]
- printf()有专门的**_占位符%zd 或%zu，用来处理 size_t 类型的值_**

```c
printf("%zd\n",sizeof(int));

// 无论sizeof返回什么都能打印出来，这就不需要上面用 %d 了
```

> 如果当前系统不支持%zd 或%zu，可使用%u (unsigned int ) 或%lu (unsigned long int ) 代替

#### 9.类型的隐式转换

- 某些情况下，C 语言会自动转换某个值的类型

##### 9.1 赋值运算

- **_浮点数赋予整数变量，会直接丢弃_**，没有什么进一去一四舍五入一回事

```c
int a = 9.999999;

// a = 9
```

- **_整数赋值给浮点数变量时，会自动转为浮点数_**

```c
float o = 0;

// o = 0.000000
```

- **字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升**，即**_窄类型自动转为宽类型_**

```c
char a = 10;

int x = a + 10;
```

> **不影响原值**，比如上面 a 还是 char，不会变成 int

- **字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型**。这时可能会发生**_截值 (truncation ) ，系统会自动截去多余的二进制位_**，导致难以预料的结果

```c
int x = 10;

char a = x;
printf("%i\n",a);

>>> 10

// 这是降级之后不影响的例子

int x = 300;
char a = x;
printf("%i\n",a);

>>> 44

// 因为 300 大于 256 ，所以打印出的是 300 & 256 的44
```

- **_浮点数赋值给整数类型的值，也会发生截值，浮点数的小数部分会被截去_**

```c
double pi = 3.1415926535823846462;

int p = pi;

// p = 3
// 没有四舍五入一回事
```

##### 9.2 混合类型计算

- 不同类型的值进行混合计算时，必须先转成同一个类型，才能进行计算，转换规则如下：
  > **整数与浮点数混合运算时**，**_整数转为浮点数类型_**，与另一个运算数类型相同

```c
3 + 1.2 // 4.2

// 上面示例是int类型与float类型的混合计算，int类型的3会先转成float的3.0，再进行计算，得到4.2
```

> **不同的浮点数类型混合运算时**，**\*宽度较小的类型转为宽度较大的类型**，比如 float 转为 double，double 转为 long double

> **不同的整数类型混合运算时**，**_宽度较小的类型会提升为宽度较大的类型_**。比如 short 转为 int，int 转为 long 等，有时还会将带符号的类型 signed 转为无符号 unsigned

- 请看下面例子，明白不要将有无符号的数字放在一块运算

```c
int a = -5;
if (a < sizeof(int)){
    main();
}
```

> sizeof 返回一个 size_t 类型，是一个无符号整数 unsigned int，**所以 a 这个有符号整数 -5 会转为 4294967291 (转换规则是-5 加上无符号整数的最大值，再加 1，详情见补码 )**，明显大于 4，不会执行 main

- 所以，**_最好避免无符号整数与有符号整数的混合运算_**，因为这时 C 语言会自动将 signed int 转为 unsigned int，可能不会得到预期的结果

##### 9.3 整数类型运算

- **两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型**。但是有一个例外，**_宽度小于 int 的类型，运算结果会自动提升为 int_**

```c
unsigned char a = 250,b = 10;

printf("%i\n",sizeof(a + b));

>>> 4

unsigned char c = a + b;

>>> 4
// 溢出
unsigned int cpp = a + b;

>>> 260
printf("char: %i,int: %i",c,cpp);
```

> 注意像 -a 这种**_一元运算符也看作运算_**，如果 a 是 char 的话也会转换

```c
char a = 10;

printf("%zd",sizeof(-a));
>>> 4
```

##### 9.4 函数

- **_函数的参数和返回值，会自动转成函数定义里指定的类型_** (函数咱们一会再讲 )

```c
int func(int,double);

char a = 'a';
long long int x = 23123;

func(a,x);
```

> 上面无论传值的类型是什么，都会**转换为形参规定的格式**

```c
int fn(void){
    float f = 0.23;
    return f;
}
```

> 无论函数返回的是什么类型，都会**等于指定的返回类型** (比如上面返回浮点数，但是会被转换为整数 )

#### 10.类型的显式转换

- 原则上，应该避免类型的自动转换，防止出现意料之外的结果。C 语言提供了类型的显式转换，允许手动转换类型
- 语法：
  > **_只要在一个值或变量的前面，使用圆括号指定类型(type)，就可以将这个值或变量转为指定的类型，这叫做"类型指定" (casting )_**

```c
(type)expression

// type 类型
// expression 表达式，变量或值

int a = 34;
(char)a;
```

> **_不改变原值_**，只是返回转换后的数据

```c
(int)9.5 / 6
```

> **_请注意优先级_**，上面会先计算 9.5 的 int 值，再除以 6，如果想让类型转换最后发生请带上括号

#### 11.可移植类型

- C 语言的**_整数类型 (short、int、long ) 在不同计算机上，占用的字节宽度可能是不一样的_**，无法提前知道它们到底占用多少个字节
- 程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，**_头文件 stdint.h 创造了一些新的类型别名_**
- 精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的

| 名称     | 意义            |
| -------- | --------------- |
| int8_t   | 8 位有符号整数  |
| int16_t  | 16 位有符号整数 |
| nt32_t   | 32 位有符号整数 |
| int64_t  | 64 位有符号整数 |
| uint8_t  | 8 位无符号整数  |
| uint16_t | 16 位无符号整数 |
| uint32_t | 32 位无符号整数 |
| uint64_t | 64 位无符号整数 |

> 上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果 int 类型为 32 位，int32_t 就会指向 int；如果 long 类型为 32 位，int32_t 则会指向 long

```c
#include <stdio.h>
#include <stdint.h>

int main(){
    int8_t int8 = 56;
    printf("%i",int8);

    return 0;
}

// 这样在任何一台电脑上 int8 都会是一个 8 位有符号整数
```

- **_最小宽度类型 (minimum width type ) ，保证某个整数类型的最小长度，可以保证占据的字节不少于指定宽度_**。比如，int_least8_t 表示可以容纳 8 位有符号整数的最小宽度的类型
  > int_least8_t  
  > int_least16_t  
  > int_least32_t  
  > int_least64_t  
  > uint_least8_t  
  > uint_least16_t  
  > uint_least32_t  
  > uint_least64_t
- **_最快的最小宽度类型 (fast minimum width type ) ，可以使整数计算达到最快的类型_**。保证字节宽度的同时，追求最快的运算速度，比如 int_fast8_t 表示对于 8 位有符号整数，运算速度最快的类型。这是因为某些机器对于特定宽度的数据，运算速度最快，举例来说，32 位计算机对于 32 位数据的运算速度，会快于 16 位数据
  > int_fast8_t  
  > int_fast16_t  
  > int_fast32_t  
  > int_fast64_t  
  > uint_fast8_t  
  > uint_fast16_t  
  > uint_fast32_t  
  > uint_fast64_t
- **_可以保存指针的整数类型_**
  > intptr_t：可以存储指针 (内存地址 ) 的有符号整数类型  
  > uintptr_t：可以存储指针的无符号整数类型
- **_最大宽度整数类型，用于存放最大的整数_**，这两个类型的宽度比 long long 和 unsigned long 更大
  > intmax_t：可以存储任何有效的有符号整数的类型  
  > uintmax_t：可以存放任何有效的无符号整数的类型  
  > ---- 但是依旧是有限的

### 陆: 常量

- 其实这章本应该归属于变量的，但是有些概念是在数据类型讲完后才能讲的，所以在这里简单一提

#### 1.概念

- **_常量就是不能改变的变量_**，其他与变量没有任何区别，变量的类型他也有

#### 2.声明

- **_C 语言提供两种常量生命方式，#define 预处理器和 const 关键字_**
  > #define 会在预处理器那章讲解

```c
const int x = 10;

x = 20;
// 会报错，因为初始化之后不能再赋值了
```

#### 3.二者区别

1. 编译器处理方式不同
   > #define 宏是在预处理阶段展开  
   > const 常量是编译运行阶段使用
2. 类型和安全检查不同
   > #define 宏没有类型，不做任何类型检查，仅仅是展开  
   > const 常量有具体的类型，在编译阶段会执行类型检查
3. 存储方式不同
   > #define 宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存 (宏定义不分配内存，变量定义分配内存 )
   > const 常量会在内存中分配(可以是堆中也可以是栈中)
4. const 可以节省空间，避免不必要的内存分配
   > #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝 (因为是全局的只读变量，存在静态区 ) ，而 #define 定义的常量在内存中有若干个拷贝
5. 提高了效率。 编译器通常不为普通 const 常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高
6. 宏替换只作替换，不做计算，不做表达式求解
   > 宏预编译时就替换了，程序运行时，并不分配内存

#### 4.类型

- 变量的类型常量，写法都通用全部都有，只不过这里区分一下字符常量，字符字面量的区别
- **_字面量全部都是常量_**
  > 比如 10 代表十个苹果，我不能说 10 = 九个苹果一样  
  > 10 != 9，**所以字面量全都是常量，也叫字面常量**
- 当我在执行 a = 3 时，就是把**_3 这个字面常量赋给 a 这个变量_**，这也解释了之前 _sizeof(c) != sizeof('c')_ 的问题，因为本来就不同

## 第二章：数据与控制

### 柒: 流程控制

- **_C 语言的程序是顺序执行，即先执行前面的语句，再执行后面的语句_**。开发者如果想要控制程序执行的流程，就必须使用流程控制的语法结构，主要是**条件执行**和**循环执行**

#### 1.if 语句

- **_if 语句用于条件判断，满足条件时，就执行指定的语句_**
- 语法：

```c
if (expression) statement

// 上面式子中，表达式expression为真  (值不为0 ) 时，就执行statement语句

// if后面的判断条件expression外面必须有圆括号，否则会报错。语句体部分statement可以是一个语句，也可以是放在大括号里面的复合语句。下面是一个例子

if (x == 10) printf("x is 10");

// 也可以

if (x == 10)
    printf("x is 10");

// 因为 C 依靠分号结尾，所以以上二者皆可，但是一般另起一行
```

- 如果有多条语句，就需要把它们放在大括号里面，**_组成一个复合语句_**

```c
if (x == 10){
    printf("x is %i\n",x);
    printf("well done! \n");
}
```

- **_if 语句可以带有 else 分支，指定条件不成立时 (表达式 expression 的值为 0 ) ，所要执行的代码_**

```c
if (expression) statement
else statement
```

```c
if (x == 10)
    printf("x is 10\n");
else
    printf("x is not 10\n");
```

> 如果 else 的语句部分多于一行，同样可以**_把它们放在大括号里面_**

- **_else 可以与另一个 if 语句连用，构成多重判断_**

```c
if (x == 10){
    printf("x is %i",x);
} else if (x == 20){
    printf("x is %i",x);
} else {
    printf("x is %i",x);
}
```

- 如果有多个 if 和 else，可以记住这样一条规则，**_else 总是跟最接近的 if 匹配_**

```c
if (number > 6)
    if (number < 12)
    printf("The number is more than 6, less than 12.\n");
else
  printf("It is wrong number.\n");
```

> 跟最近的 if (number < 12 ) 匹配，如果 number 大于 6，就不会执行 else，这跟 python 的空格缩进是不同的

- 这样很容易出错，为了提供代码的可读性，**_建议使用大括号，明确 else 匹配哪一个 if_**

#### 2.三元运算符

- C 语言有一个**_三元表达式 ? : 可以用作 if...else 的简写形式_**
- 语法：**_表达式 expression1 如果为 true (非 0 值 ) ，就执行 expression2，否则执行 expression3_**

```md
<expression1> ? <expression2> : <expression3>
```

```c
int y = 13;
int x = (y > 10) ? 20 : 23;

printf("x is %i",x);
return 0;

// 单独一个数字也能返回数值，所以可以简化if···else if···的结构
```

#### 3.switch 判断

- **_switch 语句是一种特殊形式的 if...else 结构，用于判断条件有多个结果的情况_**。它把多重的 else if 改成**更易用、可读性更好**的形式
- 语法：**_根据表达式 expression 不同的值，执行相应的 case 分支，如果找不到对应的值，就执行 default 分支_**
  > **case 后面的语句体，不用放在大括号里面**，这也是为什么需要 break 的原因

```c
switch (expression) {
    case value1: statement
    case value2: statement
    default: statement
}
```

- 特别的，**_每个 case 语句体的结尾，都应该有一个 break 语句_**，作用是跳出整个 switch 结构，不再往下执行。**如果缺少 break，就会导致继续执行下一个 case 或 default 分支**

```c
int y = 10;

switch (y){
    case 10:printf("y is 10\n");
        break;
    case 20:printf("y is 20\n");
        break;
    default:printf("i don't kown y's value");
        break;
}

// 尽量不要写成以上的格式，写成以下

int y = 10;

switch (y){
    case 10:
        printf("y is 10\n");
        break;
    case 20:
        printf("y is 20\n");
        break;
    default:
        printf("i don't kown y's value");
        break;
}
```

> 你是不是觉得 C 很傻，连自动判断都没有，其实可以根据这个特性**_选择哪些语句是所有的判断都要执行的_**

```c
int y = 10;

switch (y){
    case 10:
        printf("y is 10\n");
    case 20:
        printf("y is 20\n");
        printf("i kown y's value");
        break;
    default:printf("i don't kown y's value");
        break;
}

>>>
y is 10
y is 20
i kown y's value

// 这里case 10 和 20 都会被执行  (我还以为20不会被执行 )
```

- 也支持空语句，**_可以将 case 与空语句结合起来_**

```c
int day = 6;

switch (day){
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:printf("工作日\n");
	break;
	case 6:printf("休息日\n");
    break
	case 7:printf("休息日\n");
	break;
	}

// 这样输入 1 至 5都会返回工作日，不需要一个一个敲了
```

> 可以看出**当 case 语句后没有执行语句且没有 break 时代码会从条件判断成立进入，直到遇到 break**

- **_default 分支用来处理前面的 case 都不匹配的情况，最好放在所有 case 的后面_**，这样就不用写 break 语句。这个分支是可选的，**如果没有该分支，遇到所有的 case 都不匹配的情况，就会直接跳出整个 switch 代码块**

#### 4.while 循环

- **_while 语句用于循环结构，满足条件时，不断执行循环体_**
- 语法：如果**_表达式 expression 为非零值 (表示真 ) ，就会执行 statement 语句，然后再次判断 expression 是否为零；如果 expression 为零 (表示伪 ) 就跳出循环，不再执行循环体_**

```c
while (expression)
    statement
```

```c
int i = -9;

while (i < 10)
    i++;

// i 一直增加至10
```

- 同样的，**_多个语句要用大括号包裹起来_**

```c
#include <stdio.h>

int main(){
    int n = 1;

    while (n < 100){
        printf("n is %i\n",n);

        n++;
    }
    return 0;
}

// 一直打印到 n 等于 100
```

> 只要条件为真，while 会产生**无限循环**，但是循环体内部可以**用 break 语句跳出循环**

#### 5.do……while 循环

- **_do...while 结构是 while 的变体，它会先执行一次循环体，然后再判断是否满足条件。如果满足的话，就继续执行循环体，否则跳出循环_**
  > 跟 while 的区别就是，**while 是先判断再执行，do while 是先执行再判断**，虽然两者可以互相转换，但是**do while 主要用于人机交互**，程序执行操作，问你还需要吗，再执行
- 语法：**_不管条件 expression 是否成立，循环体 statement 至少会执行一次。每次 statement 执行完毕，就会判断一次 expression，决定是否结束循环_**

```c
do statement
while (expression);

//while 后面的分号不能忘了
```

- 如果**_循环部分有多条语句，就需要放在大括号里面_**

```c
int x = 10;

do {
    x++;
}
while (x != 10);

// 上面虽然 x 不等于10，但是还是会执行一遍do
// 再进入 while 时已经是 11 了，所以会无限循环下去
```

#### 6.for 语句

- **_for 语句是最常用的循环结构，通常用于精确控制循环次数_**
- **_for 语句的条件部分 (即圆括号里面的部分 ) 有三个表达式_**：
  > initialization：**_初始化表达式_**，**用于初始化循环变量，只执行一次**  
  > continuation：**_判断表达式_**，**只要为 true，就会不断执行循环体**  
  > action：**_循环变量处理表达式_**，**每轮循环结束后执行，使得循环变量发生变化**

```c
for (initialization; continuation; action)
    statement;

// 注意三个表达式以分号间隔
// 循环体部分的statement可以是一条语句，也可以是放在大括号里面的复合语句
```

> **虽说第一个表达式说着是赋值，但是以也可以忽略它，让他干别的或者用零代替，如果赋了值的话也是局部变量**

```c
#include <stdio.h>

int main(){
    int i = 1;

    for (char a = 1;i < 9;i++){
        printf("a is %i\ni is %i\n",a,i);
    }

    printf("i is %i",i);

    return 0;
}
```

> 没有说判断部分必须是以 for 声明的变量使用

```c
#include <stdio.h>

int main(){
    int i = 1;

    for (0;1;i--){
        i++;

        printf("i is %i\n",i);
    }

    printf("i is %i",i);

    return 0;
}

// 由于判断给了1，会一直循环
// 语句块里自增，表达式里再自减，所以i不变
```

> 后面那两个表达式也是，判断表达式只管你的值是 0 还是 1，循环变量也可以不处理循环变量

- 这里有一个有意思的点：i 一直是 2 ，**_说明第一遍时是不运行循环变量处理表达式的，同理初始化表达式也只在第一遍时执行_**
- for 的三个表达式都不是必需的，甚至可以全部省略，这会形成无限循环。

```c
for (;;){
    i++;

    printf("i is %i\n",i);
}

// 只需要写两个分号就可以省略全部条件
```

#### 7.三个特殊关键字

##### 7.1 break

- break 语句有两种用法：**_一种是与 switch 语句配套使用，用来中断某个分支的执行，这种用法前面已经介绍过了；另一种用法是在循环体内部跳出循环，不再进行后面的循环了_**

```c
for (int i = 1;i < 10;i++){
    for (int j = -1;j > -10;j--){
        printf("%i  %i\n",i,j);

        if (-3 == j){
            break;
        }
    }

}

// 以上不会输出 j = -4
```

> 需要注意，**_break 只负责跳出单层循环_**，在外面的是不会跳出的，**_同时，break 命令只能跳出循环体和 switch 结构，不能跳出 if 结构_**

##### 7.2 continue

- continue 语句用于**_在循环体内部终止本轮循环，进入下一轮循环_**，只要遇到 continue 语句，循环体内部后面的语句就不执行了，回到循环体的头部，开始执行下一轮循环

```c
for (int i = 1;i < 10;i++){
    if (5 == i) continue;

    printf("i is %i\n",i);
}

// 当 i = 5 时不会输出
```

##### 7.3 goto

> 先说一件事，很多的书里或者课上都不会讲 _goto_ ，因为它会破坏编程逻辑，一会一个跳转也看得晕，但是 _goto_ 的作用还是很大的，不讲的话太可惜，我相信看完 Python 入门的你应该已经养成了基本的思想，但对于没有的那些人，请不要以 goto 实现编程逻辑，**goto 的功能非常好使，但是请不要以 goto 组织你的代码**

- 先介绍**_标签，命名遵循变量名，在他后面的是一个语句，标签就是为这行语句起了一个名字，方便 goto 跳转，程序执行到标签的时候还是会执行的_**
- goto 这个关键字就是方便**_快速跳转到指定的标签行_**

```c
#include <stdio.h>

int gogo(char a){
    if ('N' == a)
    {
        goto wrong;
    }
    return 0;
    wrong:printf("something wrong happen. \n");
}

int main(){
    char a = 'N';

    gogo(a);

    return 0;
}
```

> **标签名一般放置在行末**，不然总是要执行

- goto 可以快速跳出多层嵌套

```c
for(...) {
    for (...) {
        while (...) {
        do {
            if (some_error_condition)
                goto skip;
        }
        while(...);
        }
    }
}

skip: // something
```

- goto 的另一个用途是提早结束多重判断。

```c
if (do_something() == ERR)
  goto error;
if (do_something2() == ERR)
  goto error;
if (do_something3() == ERR)
  goto error;
if (do_something4() == ERR)
  goto error;
```

> 上面示例有四个判断，只要有一个发现错误，就使用 goto 跳过后面的判断

- 注意，**_goto 只能在同一个函数之中跳转，并不能跳转到其他函数_**
- 还可以[拿 goto 做异常处理](https://www.cnblogs.com/trying/archive/2012/06/25/2863753.html)

### 捌：指针

> 指针这个玩意，是 C 初学时比较难搞懂的，因为它是一个低级语言中的功能，但是也是 C 语言与其他高级语言不同的地方，十分强大，也很危险，希望你看完第一章的汇编内存模型再来理解，会方便很多

#### 1.概念

- 指针也是一个值，**_值类型为指针的变量本质上和其他变量没有任何区别_**
- 指针变量存储的是一个**_内存地址_**，给指针变量赋值就是**_让这个指针变量指向这个值所在的内存_**

```c
int n = 10;

// 当我们声明一个变量时，CPU 会给这个变量分配特定的字节用来存储数据，上面声明之后就直接初始化了，所以在这个内存空间内就存入了 10 的二进制补码

---------------------
| a |   |   |   |   |       // 简易内存模型
---------------------
  ^   ^   ^   ^   ^
100  101 102 103 104        // 实际内存地址不是十进制，只是简单理解
```

- & 运算符除了当二元运算符的求余，**_还代表取出值的内存地址_**

```c
int n = 10;

print("n的内存地址是%p",&n);
>>> 000000000061FE1C

// %p 是内存地址的占位符
// 现在只要说自己是个操作系统的基本都会有内存保护，所以上面的000000000061FE1C只是一个虚拟内存
// 如果是真实的内存地址，随便写错一运行你系统就崩溃了
// 所以你放心瞎搞
```

> 利用这个运算符，就可以验证之前的变量作用域了，只要看两个变量内存地址一样不一样就行

```c
#include <stdio.h>

int func(int a){
    a = 80;
    printf("memory locaton is %p\n",&a);

    return 0;
}

int main(){

    int a = 11;
    printf("memory locaton is %p\n",&a);

    func(a);

    printf("memory locaton is %p\n",&a);

    return 0;
}

>>>
memory locaton is 000000000061FE1C
memory locaton is 000000000061FDF0
memory locaton is 000000000061FE1C

// 可见func函数内只是一个同名变量而已
```

#### 2.声明与初始化

- **_字符 \* 表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值_**

```c
int n = 10;

int* p = &n
```

> **星号可以放在变量名与类型关键字之间的任何地方**，下面的写法都是有效的。

```c
int  *intPtr;
int * intPtr;
int* intPtr;
```

> 本文为了表示指针变量也是变量，所以星号跟在类型后面

- **如果同一行声明两个指针变量**，那么需要写成下面这样

```c
// 正确
int *foo, *bar;

// 错误
int* foo, bar;
```

- 请注意，**因为不同类型的变量是按照不同的编码方式存储的，所以指向不同类型变量的指针也要按照相对应的数据类型格式存储**，比如上面因为 n 是 int，所以指针 p 也是 int 不然读出来只是乱码
  > **_指针是强类型的_**
- 声明完成后 CPU 还**_没有给指针赋值，只是使用它得到的是一个垃圾值 (野指针)_**，每一次都会随机，所以**_声明完之后一定要初始化_**

```c
int* p;

printf("%p",p);

// 可以当随机数产生器
```

- 为了防止读写未初始化的指针变量，可以养成习惯，**_将未初始化的指针变量设为 NULL_**，**NULL 在 C 语言中是一个常量，表示地址为 0 的内存空间，这个地址是无法使用的，读写该地址会报错**

```c
int* p = NULL;

printf("%p",p);

>>> 0000000000000000
```

> 下面这个是一个不错的试题，虽然函数还没讲，但是可以看一下到了函数篇讲解

```c
// 请问最后打印几？

#include <stdio.h>

void fun(int *node){
    static int N=100;
    node=&N;
}
int main(){
    int *node=NULL;
    int a=0;
    fun(node);
    a=*node;
    printf("%d\n",a);

    return 0;
}

// 解释请看函数篇传值
```

> 还请注意，**_指针变量初始化了，但是指向的变量没初始化，一样是垃圾值_**  
> 还注意，**_你给指针传入的是一个变量的地址_**，不能光传变量名，他会以为是那个变狼名的字面量，会报错

- **_指针就是一个普通的变量_**

```c
int n = 10;

int* p = &n;


100   101   102 103
 ↓     ↓     ↓   ↓
---------------------
|n=10|p=100|   |   |
---------------------
 ↑    ↓
 ↑←←←←↓

// 当我们打印 p 会发生什么？
>>> 100
// 因为指针里存储的是一个变量地址

// 那么打印 &n 的结果和打印 p 相同吗？
>>> 100
// 肯定，因为 p 里存储的就是 n 的地址

// 那么打印 &p 会是什么？
>>> 101
// 没错，还是那句话，指针就是一个普通的变量，打印他的地址和打印其他变量的地址没什么区别
```

- **不同的数据类型需要不同的内存空间，指针也需要对应的存储空间**，如果用一个 char 类型的指针指向一个指向 int 类型的指针，或者是转换为不同类型，**数据是会丢失的**，这里容易混淆请看

```c
#include <stdio.h>

int main(void){
    int a = 1025;
    int *p = &a;

    printf("size of int is %zd bytes\n",sizeof(int));
    printf("address of %i,value is %i\n",p,*p);
    printf("address of %i,value is %i\n",p+1,*(p+1));

    // 请注意在p+1加上括号，保证是先计算p+1
    // p+1的内存没有分配，所以不知道是什么值，但是因为int占4字节，所以内存地址应该是知道的

    char* pc = (char*)p;

    // 这里是一个强制转换，将int指针转换为char指针
    // 你告诉我，指针pc指向谁？是指向p再指向a？
    // 不是，pc存储的是p的值而不是p的地址，p的值是a的地址，所以pc直接指向a

    printf("size of char is %zd bytes\n",sizeof(char));
    printf("address of %i,value is %i\n",pc,*pc);

    // 注意这句话，第一个地址一定跟上面是一样的，因为说了pc就指向a
    // 但是值不同，因为pc是char类型的指针，所以他只会读取int占的四个字节里的一个

    // 你看 1025 = 00000000 00000000 00000100 00000001
    // char只读一个，不就是1吗
    printf("address of %i,value is %i\n",pc+1,*(pc+1));

    // 这里看，因为char类型只占一个字节，所以pc+1应该指向的还是a这个int类型的一部分，值为4，往上看100不就等于4吗

    return 0;
}
```

- 但是请注意，**_指针占据的内存 (不是指向) 空间是一样的，都是八字节 (很合理就是存储内存地址)_**

```c
char* a;
int* b;
double* c;
unsigned long long int* d;

printf("a\t%zd\tb\t%zd\tc\t%zd\td\t%zd\n",sizeof(a),sizeof(b),sizeof(c),sizeof(d));

// 64位都是8，32位是4
```

> 还有一种**void 指针，只能用来指向内存地址，不能取值，也不能运算**

```c
#include <stdio.h>

int main(void){
    int a = 1025;
    int *p = &a;

    printf("size of int is %zd bytes\n",sizeof(int));
    printf("address of %i,value is %i\n",p,*p);
    printf("address of %i,value is %i\n",p+1,*(p+1));

    char* pc = (char*)p;
    printf("size of char is %zd bytes\n",sizeof(char));
    printf("address of %i,value is %i\n",pc,*pc);
    printf("address of %i,value is %i\n",pc+1,*(pc+1));

    void* vp = p;
    printf("address of %i\n",vp);

    return 0;
}
```

> 指针是对内存区域的抽象。指针变量中存放着目标对象的内存地址，而与指针相复合的类型，则说明了相应内存区域中的内容具有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本可以是不可解读的；但是，如果有一个描述这块内存区域的指针存在，我们就能找到它 (地址的作用 ) ，并且合理地使用它 (类型的作用 ) 。void\* 只有其中一半的作用。因为没有明确与指针相复合的类型，所以不能解引用，也不能使用基于类型之上 (sizeof(T) ) 的指针运算

#### 3.取值

- **_\*这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值_**
  > **_这样就可以修改指定变量的值_**

```c
int n = 10;

int* p = &n;
*p = 12;

printf("n's value is %i\n",n);
printf("n's address is %p\n",&n);
printf("p's value is %p\n",p);
printf("p's address is %p\n",&p);

return 0;

/*
    n's value is 12
    n's address is 000000000061FE1C
    p's value is 000000000061FE1C
    p's address is 000000000061FE10
*/

// 因为 C 语言函数只有传值引用，所以用指针修改变量非常常见，详情见后文
```

> 那问题来了，**能不能通过指针将一个变量指向另外一个变量？**

```c
int n = 10;
int m = 20;

int* p = &n;
*p = m;

// n = 20，只是把 m 的值赋给了 n

// 你会说把*p = m* 改为 p = &m，编译器不会通过的
```

- **_当表达式 p 可以做左值时，\*&p 与 p 等价 ；当表达式 p 是指针类型（地址）时，&\*p 与 p 等价_**

```c
// 听不懂看示例

int a = 1;
printf("%d\n", a);
printf("%d\n", *&a);

int* p = &a;
printf("%d\n", p);
printf("%d\n", &*p);



if (*&a == a){
    printf("Bad World!\n");
}

if (&*p == p){
    printf("Good World!\n");
}
```

#### 4.运算

- **_指针本质上就是一个无符号整数，代表了内存地址_**，它可以进行运算，但是规则并不是整数运算的规则

1. 指针与整数值的加减运算：**_指针与整数值的运算，表示指针的移动_**

```c
int n = 10;
printf("%p\n",&n);


int* p = &n;

printf("%p\n",p);
printf("%p\n",p+1);

>>>
000000000061FE14
000000000061FE14
000000000061FE18

// 注意一个int 4个字节，所以增加了4
```

```c
int* p = (int*)100;

p += 1;

printf("%i",p);
>>>104

// 一个更简明的示例

int n = 10;
printf("%p\n",&n);

int* p = &n;
p += 1;

printf("%n\p",p);
```

- 指针只能与整数值进行加减运算，**_两个指针进行加法是非法的_**

```c
int n = 10,m = 20;

int *p = &n,*q = &m;

int* j = p + q;

// 报错
```

- **_相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位_**
- **_高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值_**
  > 注意，**减法返回的值属于 ptrdiff_t 类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同，这个类型的原型定义在头文件 stddef.h 里面**

```c
#include <stdio.h>
#include <stddef.h>

int main(){
    char a = 1,b = 2;
    printf("a's address is %p\n",&a);
    printf("b's address is %p\n",&b);

    char *p = &a,*q = &b;

    ptrdiff_t j = p - q;
    printf("p - q = %td\n",j);


    return 0;
}



// p - q = 1
// 注意占位符为 %zd ，跟 sizeof 相同
// 因为不是按整数方式计算差距，所以以下跟以上没有区别



#include <stdio.h>
#include <stddef.h>

int main(){
    int a = 1,b = 2;
    printf("a's address is %p\n",&a);
    printf("b's address is %p\n",&b);

    int *p = &a,*q = &b;

    ptrdiff_t j = p - q;
    printf("p - q = %td\n",j);


    return 0;
}


// p - q = 1
```

- **_指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数 1 (true ) 或 0 (false )_**

```c
int n = 10,m = 20;

int *p = &n,*q = &m;
printf("%i",(p > q));
return 0;

>>> 1
```

- 不要以为指针只能干这些，随着讲解深入，你会发现指针的其他强大功能

#### 5.多级指针

```c
int x = 5;
int* p = &x;

*p = 9;

// 我现在想要存储p的地址到一个变量里，这个变量应该是什么类型？
```

- **_声明一个指向指针的指针只需要在类型后面再加上一个星号 _ 即可\***

```c
int** q = &p;

// 同样存储的是一个指针的地址

100   101   102 103
 ↓     ↓     ↓   ↓
---------------------
|x=5|p=100|q=101|   |
---------------------
 ↑    ↓ ↑    ↓
 ↑←←←←↓ ↑←←←←↓
int   int*  int**
```

> 你可以一直指向下去，拥有很多星号

```c
int*** j = &q;

// 注意，j是一个int***类型，它只能存储int**类型，不能存放p，x一类
```

> 请思考下面的例子中打印出的值

```c
#include <stdio.h>

int main(void){
    int x = 5;
    int* p;

    p = &x;

    int** q = &p;
    int*** j = &q;

    printf("%i\n",p);

// p的值，因为p是一个指针存放的是内存地址，所以这里打印出的应该是x的地址

    printf("%i\n",*p);

// p指向的值，指向a，所以是5

    printf("%i\n",*q);

// 取出q指向的值，指向p，p存储的是x的地址，所以还是x的地址

    printf("%i\n",*(*q));

// 这里其实可以不加括号，但为了读者考虑应该加上
// 取出q指向的指向的值，那就是x的值，还是5

    printf("%i\n",*(*j));

// 同理，*j是q，**j就是p，还是x的地址

    printf("%i\n",*(*(*j)));

// ***j指向x，取出x的值

    ***j = 9;

// ***j = x，通过一个三级指针改变了x的值

    printf("%i\n",x);

// 当然是9

    **q = *p + 1;

// **q = x，*p = x，也就是x自增2

    printf("%i\n",x);

    return 0;
}

>>>
6422036
5
6422036
5
6422036
5
9
11
```

#### 6.指针常量和指针常量

- **_指针也是变量，变量可以通过 const 关键字使其不可再赋值，指针也可以_**

```c
int n = 10;

int * const p = &n;
```

> 这里就代表 **p 这个指针变量的值不变了**，也就是 **_p 只能指向 n_**  
> 但是，**_p 所指向的那个变量 n 的值是可以改变的_**

- 这种我们叫**指针常量，即它本身是一个常量，但是他也是一个指针**
  > 注意**_指针常量必须立即初始化_**

```c
int n = 10;

int * const p = &n;

p = &b;   // 非法
*p = 20;  // 合法
```

- 但是**请注意 const 的位置**

```c
int n = 10;

const int * p = &n;

```

> 这里的 const 没有放在 p 的旁边，而是放在了类型 int 的旁边，**_这就说明 const 符号不是用来修饰 p 的，而是用来修饰 p 所指向的那个变量的_**，因此

- 这个叫**_常量指针，即它本身是一个指针，指向一个常量_**

```c
int n = 10;

const int * p = &n;

p = &b;   // 合法
*p = 20;  // 非法
```

> 但是**并不代表 n 成为了常量，只是没法再通过 p 指针来操作了**

- **_指向常量的指针常量，即 p 和 \*p 都没法改_**

```c
const int* const p = &a;

//两种写法都可以

int const* const p = &a;
```

- **_指向常量的二维常量指针，也就是指针常量和常量指针和二维指针合并，即 p \*p \*\*p 都不能变_**

```c
int a = 1;
int* q = &a;

const int* const * const p = &q;

//两种写法都可以

int const* const * const p = &q;
```

- 这个比较拗口，但是还是很重要的，比如可以在函数内操作

#### 7._void_ 指针

- 关键字 void 并不是一个真正的数据类型，**_它体现的是一种抽象，指明不是任何一种类型_**，一般有 2 种使用场景:
  > **函数的返回值和形参**  
  > **定义指针时不明确规定所指数据的类型，也就意味着可以指向任意类型**
- 正如我们上面讲，指针也是有类型的，它们之间的互相取值，运算都是建立在**相同类型的前提下**，如果类型不同就要**强制类型转换**
- 而 _void_ 类型指针意味着**_可以把任意类型的指针赋值给自己_**，但是不能反过来操作，也就是***不能把 *void* 型指针直接赋值给其他确定类型的指针***，而**必须要强制转换成被赋值指针所指向的数据类型**
  > 所以也不存在什么 _void_ 类型占几个字节的问题，只存放地址

```c
int n = 10;
int* p = &n;
void* p1 = p;
int* p2 = (int*)p1;

printf("n is %i,p is %p,void pointer is %p,p2 is %p.\n",n,p,p1,p2);

>>>
n is 10,p is 000000000061FE04,void pointer is 000000000061FE04,p2 is 000000000061FE04.
```

- 所以 _void_ 类型的指针，**只能存放地址**，除了这以外什么运算取值都不可以

### 玖：函数

- 函数是什么就不讲了，按照数学上的定义，**函数是一个黑盒子，你给他一个输入他给你一个特定的输出**

#### 1.声明

```c
int add(int a,int b){
    return a + b;
}
```

> 这就定义了一个函数用于加法，我们注意的是

- **_函数声明时，首先需要给出返回值的类型，上例是 int，表示函数 add()返回一个整数_**
- **_函数名后面的小括号里是函数的参数_**，上面 add()接受两个整数参数
- 实参与形参：

1. 在调用有参函数时，**_函数名后面括号中的参数称为 "实参"，是我们真实传给函数的参数_**，实参可以是：常量、变量、表达式、函数等  
   无论实参是何种类型的量，在进行函数调用时，**它们都必须有确定的值**，以便把这些值传送给形参
2. **_形式参数是指函数名后括号中的变量_**，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数  
   形式参数当函数调用完成之后就自动销毁了。因此**形式参数只在函数中有效**
   > 函数调用时，**_参数个数必须与定义里面的参数个数一致_**，参数过多或过少都会报错

```c
add(2,3,4);    // 错误

add();         // 错误
```

- **_函数体要写在大括号里面，后面 (即大括号外面 ) 不需要加分号_**。大括号的起始位置，_可以跟函数名在同一行，也可以另起一行_

```c
int add(int a,int b){
    return a + b;
}

// 等于

int add(int a,int b)
{
    return a + b;
}
```

- **_return 语句给出函数的返回值，程序运行到这一行，就会跳出函数体，结束函数的调用_**。如果函数没有返回值，可以省略 return 语句，或者写成 return;

```c
int c = add(a,b);
printf("a + b is %i",c);
```

#### 2.调用

- **_调用函数时，只要在函数名后面加上圆括号就可以了，实际的参数放在圆括号里面_**

```c
add(10,90);
```

- **_函数必须声明后使用，否则会报错_**

```c
// 正确

#include <stdio.h>

int add(int a,int b){
    return a + b;
}


int main(void){
    int a = 10,b = 90;

    int c = add(a,b);
    printf("a + b is %i",c);
    return 0;
}


// 错误

#include <stdio.h>

int main(void){
    int a = 10,b = 90;

    int c = add(a,b);
    printf("a + b is %i",c);
    return 0;
}



int add(int a,int b){
    return a + b;
}
```

- C 语言标准规定，**_函数只能声明在源码文件的顶层，不能声明在其他函数内部_**
- **_不返回值的函数，使用 void 关键字表示返回值的类型。没有参数的函数，声明时要用 void 关键字表示参数类型_**
  > 这跟我们之前讲的函数返回值自动转换不同，返回值为 _void_ 的函数不能有 return 语句，**不能有返回值**
- **_函数可以调用自身，这就叫做递归 (recursion )_**，大大简化了算法但是会减少性能

#### 3._main_ 函数

- C 语言规定，**_main()是程序的入口函数，即所有的程序一定要包含一个 main()函数。程序总是从这个函数开始执行_**，如果没有该函数，_程序就无法启动_。**其他函数都是通过它引入程序的**
- **main()的写法与其他函数一样**，要给出返回值的类型和参数的类型

```c
int main(void){
    printf("Hello World!\n");

    return 0;
}
```

- C 语言约定，**_返回值 0 表示函数运行成功，如果返回其他非零整数，就表示运行失败_**，代码出了问题。系统根据 main()的返回值，作为整个程序的返回值，确定程序是否运行成功
- 正常情况下，如果 main()里面省略 return 0 这一行，编译器会自动加上，**即 main()的默认返回值为 0**

```c
// 也可以

int main(void){
    printf("Hello World!\n");
}
```

> **建议总是保留 return 语句**，以便形成统一的代码风格

#### 4.函数的参数

> 形参 (形式参数 ) ：**_函数声明和定义中的参数名称就是形参_**  
> 实参 (实际参数 ) ：当需要实际调用时，**_传递给函数的具体参数值或参数变量值就是实参_**

- 函数参数传递方式：值传递和引用传递
  > 值传递：又称为值调用，**指的是将实参的值拷贝一份给形参，此时形参和实参是两个独立的变量或值，当函数修改内部的形参值时，不会影响外部的实参值**  
  > 引用传递：又称为引用调用，是指**直接将实参传给函数形参，相当于函数内部直接可以访问到外部的实参**
- 在 C 语言里，如果**函数的参数是一个变量**，那么调用时，**_传入的是这个变量的值的拷贝，而不是变量本身_**，也就是 **C 语言只有传值引用**

```c
#include <stdio.h>

void func(int i){
    i++;

    printf("i is %i\n",i);
}


int main(void){
    int i = 10;
    func(i);

    printf("i is %i\n",i);

    return 0;
}

// i 并没有改变，拷贝的变化，影响不到原始变量
```

> 所以，如果参数变量发生变化，最好把它作为返回值 _return_ 传出来

- _如果真的想要改变传入变量本身_，只有一个办法，就是**_传入变量的地址_**

```c
#include <stdio.h>

void swap(int* a,int* b){
    int t = *a;

    *a = *b;
    *b = t;

}


int main(void){
    int a = 5,b = 10;
    printf("a is %i, b is %i\n",a,b);

    swap(&a,&b);

    // 你传入参数的地址，这就是传入一个指针，因为指针存着的就是地址

    printf("a is %i, b is %i\n",a,b);

    return 0;
}
```

> 切忌，**_函数不要返回内部变量的指针_**，因为当函数结束时，内部变量就被释放了，你再去调这个指针是会发生*危险的事情的*

- 再结合上面的内存模型讲一讲

```c
|      |
|------| --> 600
|      |
|      | --> // 这就是堆区
|      |
|------| --> 500
|      |
|______| --> // 这就是栈区
|other | --> // 当一个其他函数被调用时，是把实参拷贝一份到函数里，函数一结束，这个栈就被回收了
|——————|
| main | --> // 当main运行时，就会在这里新建一个main的栈帧stack frame
|------| --> 200
|static|
|global| --> // 这部分存储的是全局变量，作用域是整个程序
|------| --> 100
|      |     // 当然底下还有

// 但是当我们传入一个指针时，他是直接跳过栈之间的限制指着另外一个栈中的变量修改，是直接修改
```

#### 5.函数指针

> 话说在前，讲的是**函数指针**，不是指针函数，两个概念不一样

- 咱们再重温一下内存模型，请记住这几句话：
  > **CPU 在访问内存的时候需要的是地址，而不是变量名、函数名，编译器负责将程序中的所有变量名，函数名转换为地址**  
  > 指针变量也是变量，拥有变量的两个重要特征**_类型和值_**，这是在定义指针时就已经决定好的，那么
- **_函数本身也在内存中，当然也可以用指针获取到函数的地址_**

```c
// 这是一段很普通的代码，接下来的变量名以及函数名均已下为准

#include <stdio.h>

void print_num(int n){
    printf("num is %i",n);
}

int main(void){
    int a = 10;

    print_num(a);

    return 0;
}
```

- 函数指针的本质还是一个指针变量，所以声明格式上是差不多的，格式为**_函数返回类型 (\*指针变量名)(函数参数列表);_**

```c
void (*p_of_print_num)(int);

// 因为print_num返回void，所以这个指针也要返回void，第一个单词是void
// 最后面的括号里只需要写参数的类型，不用传参，有几个写几个
// (*p_of_print_num)一定要加括号，不然(int)优先级高，会报错
```

> 这里之所以函数指针的类型取决于函数的返回值，就是相当于声明指针变量时的类型，函数的类型就当作指针的类型

```c
void (*p_of_print_num)(int) = &print_num;

// 赋值时可以直接通过&操作得到函数的地址

p_of_print_num = &print_num;

// 也可以先声明，再通过声明过的指针变量名赋值
```

- **_通过取值函数指针就可以调用函数_**

```c
(*p_of_print_num)(15);

// 等于

print_num(15);

// 注意，第一行第二个括号就是传参的括号，第一个不加的话会报错
```

- 比较特殊的是，C 语言还规定，**_函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址_**，也就是说，print_num 和&print_num 是一回事

```c
if (print_num == &print_num) // true
```

- 所以上面的**赋值也可以写成不带&**

```c
p_of_print_num = &print_num;

// 等于

p_of_print_num = print_num;

if (p_of_print_num == print_num){
    printf("Yes!\n");
}

// Yes!
if (p_of_print_num == &print_num){
    printf("Yes!\n");
}

// Yes!
```

- 所以，**对于任意函数，都有五种调用函数的写法**

```c
// 写法一
print(10)

// 写法二
(*print)(10)

// 写法三
(&print)(10)

// 写法四
(*print_ptr)(10)

// 写法五
print_ptr(10)
```

> 为了简洁易读，一般情况下，**函数名前面都不加\*和&**

- 这种特性的一个应用是，如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成下面这样

```c
int compute(int (*myfunc)(int), int, int);

// 上面示例可以清晰地表明，函数compute()的第一个参数也是一个函数
```

#### 6.指针函数

> 简单说一下函数指针容易混淆的点以及应用

- **_函数指针指的是返回值为指针的一个函数_**，因为星号优先级较高，一定要注意这个**星号不在括号内**，表示这个函数返回一个**int\* 类型的指针**

```c
int *p_of_print_num(int);
```

> 当然，函数本身也可能返回一个函数指针，后面会说到

| 名称 (xx 指针) | 含义 (指向...的指针)                   | 定义形式                                                  | 指针 p 的类型 typeid(p).name |
| -------------- | -------------------------------------- | --------------------------------------------------------- | ---------------------------- |
| 变量指针       | 指向变量的指针                         | int *p=&a / int (*p)=&a                                   | int \*                       |
| 常量指针       | 指向常量的指针                         | int const *p=&a(括号省略了) / const int *p=&a(括号省略了) | int const \*                 |
| 一维数组指针   | 指向一维数组(首元素)的指针             | int \*p=a(括号省略了)                                     | int \*                       |
| 二维数组指针   | 指向二维数组(第一行整体是首元素的指针) | int (\*p)[4]=a                                            | int (\*)[4]                  |
| 函数指针       | 指向函数的指针                         | int (\*p)(int a,int b)=add                                | int (\*)(int,int)            |

> 数组指针后面讲

- **函数可以接受一个函数指针的参数，然后在函数内调用它**

```c
#include <stdio.h>
#include <stdbool.h>


bool less(int a,int b){
    return a < b;
}


bool bigger(int a,int b){
    return a > b;
}

// 上文定义两个比较函数，返回0和1

void comparator(int a,int b,bool (*p)(int,int)){
    // 注意这里的参数是一个返回值为bool的名字为p接受两个参数的函数指针
    if (p(a,b)){
        // 通过指针向外引用函数返回bool值
        printf("a is less than b");
    } else {
        printf("a is bigger than b");
    }
}


int main(int argc, char const *argv[])
{
    int a = 98,b = 54;

    comparator(a,b,&less);

    // 传值时也可以不写&，这里是为了直观

    return 0;
}

// 所以，函数回调本质为函数指针作为函数参数，函数调用时传入函数地址，这使我们的代码变得更加灵活，可复用性更强。

// 说了这么多，其实函数指针作为函数参数很简单，我们只要能知道函数指针的类型即可，一般格式如下：

void MyFunction(..., int (*p)(int,int),....)
```

> 下面是一些常见的函数指针，注意函数的返回值和参数类型要匹配哦！！！另外注意解引用运算符\*上面的括号不能掉啊！！！

```c
int (*p)(int,int)   //有参数，有返回值的函数
void (*p)(int,int)  //有参数，无返回值的函数
void (*p)()         //无参数，无返回值的函数
void (*p)(void)
```

- 函数既然可以作为参数，自然也可以作为返回值，即**_返回值为指针函数的函数_**、
  > 比如：  
  > funcA*接受两个参数，返回一个指针函数*funcB，参数一个是 char 字符，另一个是 funcB，即接受 B 也返回 B  
  > funvB*接受两个整数参数，返回整数*

```c
// 首先指向函数B的指针应该是

int (*p)(int a,int b) = funcB;
```

```c
// 那么这个指针的类型应该是

int (*)(int,int);
```

```c
// 那我们按照逻辑去想A的定义应该是：

int (*)(int,int) funcA(char c,int (*p)(int,int)){
    // ^            ^     ^             ^
    //函数返回类型 函数名 参数1         参数2
}
```

> 事实上编译器看不懂，正确的应该是

```c
int (*funcA(char c,int (*p)(int,int)))(int,int){
    // ···
    // 是不是晕了
}
```

> 一步一步解读

```c
int (*funcA(char c,int (*p)(int,int)))(int,int){
    // ···
}

// 首先funcA(char c,int (*p)(int,int))是一个接受字符和指针函数的函数
// *funcA(char c,int (*p)(int,int))相当于返回一个指针，把这个整体看作函数指针的定义中的p

int *p(int,int); // 指针函数 (返回指针的函数) 定义

// 把上面一段话当作p的话，加上括号变成 (*funcA(char c,int (*p)(int,int)))
// 相当于是返回一个指针函数要依着它的定义来，再来就看这个返回值的类型及参数了，也就是funB
// 那就是int (int,int)吗，于是如图
```

> 实例应用：

```c
#include <stdio.h>


int add(int a,int b){
    return a + b;
}


int (*confirm(char c,int (*p)(int,int)))(int,int){
    if ('Y' == c){
        return p;
    } else {
        return NULL;
    }
}


int main(int argc, char const *argv[])
{
    char Y = 'Y',n = 'n';
    int a = 10,b = 45;

    int (*poi)(int,int) = confirm(Y,add);
    printf("confirm sum is %i",poi(a,b));

    return 0;
}

// 这里也有一个注意点，返回null不会报错，但是0，void会
```

#### 7.函数原型

- 上文说过，函数是**先声明再使用**，导致**所有的函数必须声明在 main 函数之前**，那我不想这样怎么办？
- C 语言提供的解决方法是，**_只要在程序开头处给出函数原型，函数就可以先使用、后声明_**。所谓**函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型**。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上

```c
#include <stdio.h>

void print(int);

int main(void){
    int n = 10;

    print(n);

    return 0;
}

void print(int n){
    printf("your num is %i",n);
}

// 虽然print的定义在main之后，但是先声明原型即可，所以可以正确编译
```

> **函数原型包括参数名也可以**，虽然这样对于编译器是多余的，但是阅读代码的时候，可能有助于理解函数的意图

```c
void print(int);

// 等于

void print(int n);
```

> 请注意**函数原型之后要有分号**

#### 8.exit()

- **_exit()函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束_**。该函数的原型定义在**头文件 stdlib.h 里面**
- **_exit()可以向程序外部返回一个值，它的参数就是程序的返回值_**。一般来说，使用两个常量作为它的参数：**EXIT_SUCCESS (相当于 0 ) 表示程序运行成功，EXIT_FAILURE (相当于 1 ) 表示程序异常中止**。这两个常数也是定义在 stdlib.h 里面

```c
// 程序运行成功
// 等同于 exit(0);
exit(EXIT_SUCCESS);

// 程序异常中止
// 等同于 exit(1);
exit(EXIT_FAILURE);
```

> **在 main()函数里面，exit()等价于使用 return 语句**。**其他函数使用 exit()，就是终止整个程序的运行**，没有其他作用

- C 语言还提供了一个**_atexit()函数，用来登记 exit()执行时额外执行的函数，用来做一些退出程序时的收尾工作_**。该函数的原型也是定义在**头文件 stdlib.h**

```c
int atexit(void (*func)(void));
```

> **atexit()函数的参数是一个函数指针**，函数指针指向一个**_没有参数也没有返回值的函数_**

```c
#include <stdio.h>
#include <stdlib.h>

void succes(void){
    printf("succes!\n");
}

void wrong(void){
    printf("wrong!\n");
}

int main(void){
    int n = 0;

    if (0 == n){
        atexit(succes);
        exit(EXIT_SUCCESS);
    } else {
        atexit(wrong);
        exit(EXIT_FAILURE);
    }
}

// exit()执行时会先自动调用atexit()注册的打印函数，然后再终止程序
```

- 再讲的细一点，atexit 函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数
- ⼀个进程可以登记若⼲个 (具体⾃⼰验证⼀下 ) 个函数，这些函数由 exit ⾃动调⽤，这些函数被称为终⽌处理函数， atexit 函数可以登记这些函数。 exit 调⽤终⽌处理函数的顺序和 atexit 登记的顺序相反 (网上很多说造成顺序相反的原因是参数压栈造成的，参数的压栈是先进后出，和函数的栈帧相同 ) ，如果⼀个函数被多次登记，也会被多次调⽤
- exit()和\_exit()以及\_Exit()函数的本质区别是是否立即进入内核，\_exit()以及\_Exit()函数都是在调用后立即进入内核，而不会执行一些清理处理，但是 exit()则会执行一些清理处理，这也是为什么会存在 atexit()函数的原因，因为 exit()函数需要执行清理处理，需要执行一系列的操作，这些终止处理函数实际上就是完成各种所谓的清除操作的实际执行体
  > 上面这一堆废话觉得不错，引用来看看

```c
#include<stdio.h>
#include<stdlib.h>  //atexit函数所属头文件

void func1()
{
    printf("The process is done...\n");
}
void func2()
{
    printf("Clean up the processing\n");
}
void func3()
{
    printf("Exit sucessful..\n");
}
int main()
{
　　//其作用是注册某一个函数，当进程执行结束时，会自动调用注册的函数
　　//注册几次，就执行几次
    atexit(func1);
    atexit(func2);
    atexit(func3);
    exit(0);
}


>>>
Exit sucessful..
Clean up the processing
The process is done...
```

- 我们可以看到**atexit 函数的调用顺序是和登记顺序相反的**

#### 9.函数说明符

- C 语言提供了一些函数说明符，**让函数用法更加明确**

##### 9.1 extern 说明符

- 对于多文件的项目，源码文件**会用到其他文件声明的函数**。这时，**当前文件里面，需要给出外部函数的原型**，并**_用 extern 说明该函数的定义来自其他文件_**

```c
/*
    hello.h
*/


int a = 10;

int add(int a,int b){
    return a + b;
}


/*
    hello.c
*/

#include <stdio.h>
#include "hello.h"

extern int add(int,int);
extern int a;

int main(void){
    int b = 12;

    printf("a + b is %i",add(a,b));

    return 0;
}

// 预处理命令马上讲
```

> 不过，**由于函数原型默认就是 extern**，所以这里不加 extern，效果是一样的  
> 虽然还没有讲 _#include_，但是这里先介绍一下**多文件的编译**

- 简单来说有两种引用外部变量或函数的方式：**_#include 和 extern_**，二者的区别是
  > #include 是告诉编译器**_我要把这个头文件里的东西都包括进来_**，你可以*include 系统便准库*，也可以*include 自己的 .h 头文件*，**编译时只需要编译这一个.c 文件即可**，**不需要 extern**就可以使用，但是**不 include 是没有办法使用.h**里的定义的

```c
/*
    a.h
*/

int a = 10;

void print_num(int n){
    printf("n is %i",n);
}

// 注意这里并没有对printf的定义，但是不会报错
// 如果这里加上对stdio的引入，a.c里不引入也不会报错
```

```c
/*
    a.c
*/

#include <stdio.h>
#include "a.h"

// <引用标准库>
// "引用自定义"
// 同在一目录下可直接说名字，不一样要输入绝对地址

int main(void){

    print_num(a);

    return 0;

}
```

```c
gcc a.c
```

> 但是 _extern_ 不同，他只告诉编译器**_这个变量或函数要在其他源码里找，怎么找，你给编译器信息_**

```c
/*
    b.c
*/

#include <stdio.h>

// 这里就不能省略stdio了

int a = 10;

void print_num(int n){
    printf("n is %i",n);
}

```

```c
/*
    a.c
*/

extern int a;
extern void print_num(int);

int main(void){

    print_num(a);

    return 0;

}
```

```c
gcc a.c b.c

// 需要注意顺序无所谓
// 只能有一个main函数，否哦会报错重定义
// 你可以看作编译器就是把两个源码文件混到一块，当然只能有一个main函数
// 当然，变量名和函数名也不可以重定义
```

- 下面是几个例子，很容易搞错，如果的话以后会来这里看就行

1. 在 a.h 文件中定义一个变量，在 a.c 文件中引用，不 include 的话会报错，未定义这个变量

```c
/*
    a.h
*/

int a = 10;
```

```c
/*
    a.c
*/

#include <stdio.h>
extern int a;

// 这里extern也没用，因为.h没法通过编译器传参输入

int main(void){
    printf("a is %i",a);

    return 0;
}
```

```c
gcc a.c

a.c: In function 'main':
a.c:7:22: error: 'a' undeclared (first use in this function)
     printf("a is %i",a);
                      ^
a.c:7:22: note: each undeclared identifier is reported only once for each function it appears in
```

2. 在 a.c 文件中定义一个变量，在 b.c 文件中引用，成功调用

```c
/*
    b.c
*/

int b = 10;
```

```c
/*
    a.c
*/

#include <stdio.h>
extern int b;

int main(void){
    printf("b is %i",b);

    return 0;
}
```

```c
gcc a.c b.c

// 成功
```

3. **extern int a = 5 与 int a = 5 意义是一样的，都是定义**。而 extern int a;是**声明，但会产生一条警告**

```c
/*
    b.c
*/

extern int b = 10;
```

````c
/*
    a.c
*/

#include <stdio.h>
extern int b;

int main(void){
    printf("b is %i",b);

    return 0;
}
```c
gcc a.c b.c

b.c:5:12: warning: 'b' initialized and declared 'extern'
 extern int b = 10;
            ^

// 成功
````

4. **引用函数跟引用变量是一样的**，如果需要调用其他.c 文件中的函数，在文件中的**_函数声明前加 extern 即可，不加 extern 而直接声明函数也可以，因为声明全局函数默认前面带有 extern_**

```c
/*
    b.c
*/

#include <stdio.h>

void print_num(int n){
    printf("n is %i",n);
}
```

```c
/*
    a.c
*/

extern void print_num(int);

// 有没有extern都行，因为gcc传参了

int main(void){
    int a = 12;

    print_num(a);

    return 0;
}
```

```c
gcc a.c b.c

// 成功
```

5. **在 a.h 里定义一个变量，a.c 和 b.c 都包含这个.h 文件，编译的时候就会报错**

```c
/*
    a.h
*/

int n = 10;
```

```c
/*
    b.c
*/

#include "a.h"
```

```c
/*
    a.c
*/

#include <stdio.h>
#include "a.h"

int main(void){
    printf("hello!\n");

    return 0;
}
```

```c
gcc a.c b.c

C:\Users\Blueder\AppData\Local\Temp\ccF7ctMm.o:b.c:(.data+0x0): multiple definition of `n'
C:\Users\Blueder\AppData\Local\Temp\ccTBLiRi.o:a.c:(.data+0x0): first defined here
collect2.exe: error: ld returned 1 exit status
```

> 为什么呢？，还是那句话**include 相当于是把头文件里的所有东西都拷贝了一份进来，那两个文件都用当然会有重复定义**

> 那怎样才能避免这些问题，**_最好的是将不同的源码文件分开，再定义一个头文件包含这些源码，主文件只引入这一个头文件_**

```c
/*
    b.c
*/

int add(int,int){
    return a+b;
}

/*
    c.c
*/

int sub(int,int){
    return a-b;
}

/*
    a.h
*/

extern int add(int,int);
extern int sub(int,int);

/*
    a.c
*/

#include <stdio.h>
#include "a.h"

int main(void){
    int n = 10,m = 20;
    printf("n - m is %i\n",sub(n,m));
    printf("n + m is %i\n",add(n,m));

    return 0;
}


$ gcc a.c
```

- 这个 _extern_ 和 _#include_ 用哪个自己决定就好，**只要利于程序逻辑化和封装就行**，但是肯定会遇到一点问题，来这里再看看就行
- 但是，**_变量声明时，同时进行初始化，extern 就会无效_**

```c
// extern 无效
extern int i = 0;

// 等同于
int i = 0;

// extern对变量初始化的声明是无效的。这是为了防止多个extern对同一个变量进行多次初始化
```

- **函数内部使用 extern 声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值**
- **_函数本身默认是 extern_**，即该函数可以被外部文件共享，通常省略 extern 不写。如果只希望函数在当前文件可用，那就需要在函数前面加上 static

```c
extern int f(int i);
// 等同于
int f(int i);
```

- 多个源码文件的项目，编译时需要所有文件一起编译。哪怕只是修改了一行，也需要从头编译，非常耗费时间
- 为了节省时间，**_通常的做法是将编译拆分成两个步骤_**

1. 第一步，**_使用 GCC 的-c 参数，将每个源码文件单独编译为对象文件 (object file)_**

```c
$ gcc -c a.c
$ gcc -c b.c

// 或者直接把所有以c扩展名的都编译

$ gcc -c *.c
```

2. 第二步，**_将所有对象文件链接在一起，合并生成一个二进制可执行文件_**

```c
$ gcc a.o b.o

// 或者直接把所有对象文件统统编译

$ gcc *.o
```

> 还有一个编译管理工具 **makefile** ，有时间的时候跟 git 一块讲了

##### 9.2 static 说明符

- 默认情况下，**每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值**，这个之前讲过，_函数中的变量存储于栈空间内，每一次调用栈空间回收值都会归零_，但是*static 说明符*可以改变这种行为
- **_static 用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化_**。也就是说，**它的值在两次调用之间保持不变**

```c
#include <stdio.h>

void counter(void) {
    static int count = 1;  // 只初始化一次
    printf("%i\n", count);
    count++;
}

int main(void) {
    counter();  // 1
    counter();  // 2
    counter();  // 3
    counter();  // 4
}
```

- 使用 static 修饰符定义的是**静态局部变量**，存储于进程的全局数据区，在**块级作用域中**，即使在声明时未赋初值，**_编译器也会把它初始化为 0_**

```c
static int func;
// 等同于
static int func = 0;
```

- **_静态局部变量，即使函数返回，它的值也会保持不变_**

```c
#include <stdio.h>

void func(void){
    static int n = 10;
    printf("n is %i",n);
    n++;
}


int main(void){
    func();

    printf("n is %i",n);

    return 0;
}
```

> 之所以 n 存储于全局但是不能调用，是因为**其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束**  
> 静态局部变量的效果跟全局变量有一拼，但是位于函数体内部，就**极有利于程序的模块化了**

- 这样有一个好处就是**可以返回函数内部变量的指针**，因为它不会被释放

```c
int* func(void){
    static int i = 9;

    return &i;
}

// 这样函数以外也可以操作这个变量
```

- static 还有一个作用，当作用域于全局的变量和函数，是可以随便被其他文件引用的，但是**_被 static 修饰过的变量或函数，是不能被其他文件引用的，也不会带来重定义的问题_**
  > 在定义不需要与其他文件共享的全局变量时，加上 static 关键字**能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用**

```c
/*
    a.h
*/

static int s = 312;

```

```c
/*
    b.c
*/

#include "a.h"

extern int a;

static int b = a;
```

```c
/*
    a.c
*/

#include <stdio.h>
#include "a.h"

int a = 83;
extern int b = 34;

int main(void){
    printf("guess b is %i",b);

    return 0;
}
```

```c
gcc a.c b.c

// 你猜猜b是几

// 1.#include了两次不会报错就是因为用了static，其他文件读不到
// 2.int a是一个全局变量，能被b.c读到
// 3.b.c里定义了静态变量b，但是a里面读不到，但是不会报错，只是会警告，见上文
// 4.所以b是34？其实谁都不是，因为会报错，因为：

>>>
a.c:5:12: warning: 'b' initialized and declared 'extern'
 extern int b = 34;
            ^
b.c:5:16: error: initializer element is not constant
 static int b = a;
                ^
```

- **_注意，static 修饰的变量初始化时，只能赋值为常量 (或是说字面量 ) ，不能赋值为变量_**

```c
int i = 3;
static int j = i; // 错误
```

> 所以上面的例子会报错是因为 _将变量 a 赋给了静态变量 b_，这是不对的

- 同样的，**static 也可以修饰函数，这样其他文件就无法引入，当然也不会带来重定义问题**

```c
/*
    a.h
*/

static void my_func(void){
    static int m = 10;
    printf("m is %i\n",m);
    m++;
}
```

```c
/*
    b.c
*/

#include <stdio.h>
#include "a.h"

static void your_func(void){
    static int n = 10;
    printf("n is %i\n",n);
    n++;
}
```

```c
/*
    a.c
*/

#include <stdio.h>
#include "a.h"

extern void your_func(void);

int main(void){
    my_func();

    return 0;
}
```

```c
gcc a.c b.c

// 这个会报错，因为a不能引用b里面的静态函数，但是
```

> 这里面有个坑，就是 a 是可以访问到 a.h 头文件里的静态函数的，还是**因为头文件是拷贝一份，不是引用，所以可以调用到 my_func**

- **static 也可以用在参数里面，修饰参数数组** (一会讲 )

```c
int sum_array(int a[static 3], int n) {
  // ...
}

// 上面示例中，static对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，static仅可用于第一维的说明
```

- 最后再说一句，在指针篇的第二小节，讲了一道试题，当时没有讲，现在可以回头看一看，讲解一下

```c
#include <stdio.h>

void fun(int *node){
    static int N=100;
    node=&N;
}
int main(){
    int *node=NULL;
    int a=0;
    fun(node);
    a=*node;
    printf("%d\n",a);

    return 0;
}

// 0 or 100?

// 1.首先node这个指针是null的地址，也就是零。然后声明了一个a的整数值为零
// 2.把node传给fun这个函数，在函数里声明一个静态变量N等于100，把node的值改为n的地址
// 3.问题就来了虽然N是一个静态变量，但是node的是一个传值引用，出了这个函数node就被释放掉了，所以说Note现在还是指向零  (更别说静态变量的作用域出了函数也访问不到 )
// 4.你把a赋为node的值，是什么零吗？不是这会报错的，所以说这个结果不是100也不是0
```

##### 9.3 const 说明符

- **_函数参数里面的 const 常量说明符，表示函数内部不得修改该参数变量_**

```c
void f(int* p) {
  // ...
}
```

> 上面示例中，函数 f()的参数是一个指针 p，**函数内部可能会改掉它所指向的值\*p，从而影响到函数外部**

- 为了避免这种情况，**_可以在声明函数时，在指针参数前面加上 const 说明符，告诉编译器，函数内部不能修改该参数所指向的值_**

```c
void f(const int* p) {
  *p = 0; // 该行报错
}
```

> 上面示例中，声明函数时，const 指定不能修改指针 p 指向的值，所以\*p = 0 就会报错

- 但是跟上面讲常量时相同，这种***也只能限定*p 的值不可变，但 p 本身存储的地址值还是可变的\***

```c
void f(const int* p) {
  int x = 13;
  p = &x; // 允许修改
}
```

> 如果想限制修改 p，可以把 const 放在 p 前面

```c
void f(int* const p) {
  int x = 13;
  p = &x; // 该行报错
}
```

- ***如果想同时限制修改 p 和*p，需要使用两个 const\***

```c
void f(const int* const p) {
  // ...
}
```

#### 10.可变参数

> 讲到这里先说一句，C 语言由于比较原始所以**并没有什么关键字参数和默认参数的原生支持，但是可以自己造**，为了节省时间就不介绍了，网上有解决方法，这里介绍一下可变参数

> 因为之前对于汇编指令并没有太深度讲解，所以这里也不会对这几个参数讲解原理，了解了知道怎么使用就好，以下复制的是廖老师的文章

- 有些函数的参数数量是不确定的，**_声明函数的时候，可以使用省略号...表示可变数量的参数_**

```c
int printf(const char* format, ...);
```

> 上面示例是**printf()函数的原型**，除了第一个参数，其他参数的数量是可变的，与格式字符串里面的占位符数量有关。这时，就可以用...表示可变数量的参数。

- 注意，**_...符号必须放在参数序列的结尾_**，否则会报错。
- **头文件 stdarg.h 定义了一些宏，可以操作可变参数**:

1. va_list：**一个数据类型，用来定义一个可变参数对象**。它必须在操作可变参数时，首先使用
2. va_start：**一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位**
3. va_arg：**一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数**。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。
4. va_end：**一个函数，用来清理可变参数对象**

```c
#include <stdio.h>
#include <stdarg.h>

double average(int i, ...) {
    double total = 0;
    va_list ap;
    va_start(ap, i);
    for (int j = 1; j <= i; ++j) {
        total += va_arg(ap, double);
    }
    va_end(ap);
    return total / i;
}


int main(void){
    printf("average is %d",average(5,3,9,8,2))
}
```

> 上面示例中，va_list ap 定义 ap 为可变参数对象，va_start(ap, i)将参数 i 后面的参数统一放入 ap，va_arg(ap, double)用来从 ap 依次取出一个参数，并且指定该参数为 double 类型，va_end(ap)用来清理可变参数对象

### 拾：数组

> 终于将函数讲完了，太长了

#### 1.概念

- **_数组 (Array)是一组相同类型的值，按照顺序储存在一起，数组通过变量名后加方括号表示，方括号里面是数组的成员数量_**

```c
int nums[10];

// 声明一个长度为10的nums数组
// 每个成员都是相同的类型，比如这里nums里全都是int
```

> 注意，**_声明数组时，必须给出数组的大小_**

- **_数组的成员从 0 开始编号_**，所以数组 nums[10]就是从第 0 号成员一直到第 9 号成员，**最后一个成员的编号会比数组长度小 1**
- **_数组名后面使用方括号指定编号，就可以引用该成员，也可以通过该方式，对该位置进行赋值_**

```c
int a = nums[0];

nums[6] = 12;
```

> 同理，**没有初始化的数组内容是垃圾值**

```c
#include <stdio.h>

int main(int argc, char const *argv[]){
    int nums[10];

    for (int i = 0; i < 10; i++){
        printf("nums[%i] value is %i address is %p\n",i,nums[i],&nums[i]);
    }

    return 0;
}


// 注意每一个内存地址加4，对应int的存储空间
// 也注意每一个数字的内存地址是连续的

// 这个main的参数不是void，是什么后面命令行参数会讲，这里只是vscode自动补上的
```

> **如果引用不存在的数组成员 (即越界访问数组) ，并不会报错，所以必须非常小心**，把上面的 for 条件改成 100 就行了，你就看到一堆垃圾值，如果你把越界的值修改了很有可能动了你不该动的

- **_数组也可以在声明时，使用大括号，同时对每一个成员赋值_**

```c
int nums[3] = {5,56,998};

// 下面是错的

nums = {6,98,2};
```

> 注意，**_使用大括号赋值时，必须在数组声明时赋值_**，否则编译时会报错

```c
int a[5];
a = {22, 37, 3490, 18, 95}; // 报错
```

> 报错的原因是，C 语言规定，**数组变量一旦声明，就不得修改变量指向的地址**，具体会在后文解释。由于同样的原因，数组赋值之后，再用大括号修改值，也是不允许的

```c
int a[5] = {1, 2, 3, 4, 5};
a = {22, 37, 3490, 18, 95}; // 报错
```

> 注意是不能修改变量指向的地址，而不是不能改变量的值，**变量的值是可变的**

- 使用大括号赋值时，**_大括号里面的值不能多于数组的长度_**，否则编译时会报错
- 如果**_大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为 0_**

```c
int a[5] = {22, 37, 3490};
// 等同于
int a[5] = {22, 37, 3490, 0, 0};
```

```c
// 如果要将整个数组都为零，可以直接

int nums[1000] = {0};

// 全为零
```

- 也可以**_指定成员位置赋值_**

```c
int nums[10] = {[1] = 10,[9] = 234,[5] = 89};

// 其余都为0
// 顺序无所谓，可以随意调换
```

- **指定位置的赋值与顺序赋值，可以结合使用**

```c
int nums[10] = {1,[9] = 20,45,34,[6] = 23,32,3};
```

> **可以重定义**，以最后一次的赋值为准

```c
int nums[10] = {1,[0] = 23,[0] = 34};

// nums[0] = 34
```

- C 语言**_允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度_**

```c
int a[] = {22, 37, 3490};

// 等同于

int a[3] = {22, 37, 3490};
```

- **_省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加 1_**

```c
int a[] = {[2] = 6, [9] = 12};

// 上面示例中，数组a的最大指定位置是9，所以数组的长度是10
```

#### 2.长度

- **_sizeof 运算符会返回整个数组的字节长度_**

```c
int nums[] = {22, 37, 3490};
int numsLen = sizeof(nums);

// 注意是字节长度，int = 4 * 3，所以是12
```

- 由于数组成员都是同一个类型，每个成员的字节长度都是一样的，**_所以数组整体的字节长度除以某个数组成员的字节长度，就可以得到数组的成员数量_**

```c
num = sizeof(nums) / sizeof(nums[0])
```

- sizeof 返回值的数据类型是 size_t，**所以 sizeof(a) / sizeof(a[0])的数据类型也是 size_t，在 printf()里面的占位符，要用%zd 或%zu**

```c
int x[12];

printf("%zu\n", sizeof(x));     // 48
printf("%zu\n", sizeof(int));  // 4
printf("%zu\n", sizeof(x) / sizeof(int)); // 12
```

#### 3.多维数组

- C 语言**_允许声明多个维度的数组，有多少个维度，就用多少个方括号_**，比如二维数组就使用两个方括号

```c
int nums[5][5];
```

> 上面示例声明了一个二维数组，第一个维度有 5 个成员，第二个维度也有 5 个成员

- 你**_可以把多维数组理解成第一维的每一个成员都还是一个数组_**，上面第一维每一个成员都是一个拥有 5 个成员的数组，因此上面那个二维数组一共有 5 \* 5 = 25 个整数
  > 不建议理解为行列方式，因为人家不是那样子存储的
- 跟一维数组一样，**_多维数组每个维度的第一个成员也是从 0 开始编号_**
  > 三维数组需要三个方括号，以此类推可以多维

```c
int numss[5][5][5];
```

- **_引用二维数组的每个成员时，需要使用两个方括号，同时指定两个维度_**

```c
int nums[2][1] = 56;
int nums[0][0] = 8;
```

> 注意，nums[0][0]不能写成 nums[0, 0]，因为 0, 0 是一个逗号表达式，返回第二个值，所以**nums[0, 0]等同于 nums[0]**

- **_多维数组也可以使用大括号，一次性对所有成员赋值_**

```c
int a[2][5] = {
    {0, 1, 2, 3, 4},
    {5, 6, 7, 8, 9}
};

// 同样，理解为一维有2个成员 (最外面的括号)，每一个成员又有5个成员 (里面的两个括号)
```

- **也可以只使用一个大括号，自动赋值**

```c
int nums[2][3] = {1,2,3,4,5,6};

// 等于

int nums[2][3] = {
    {1,2,3},
    {4,5,6}
};
```

- 多维数组也**_可以指定位置，进行初始化赋值_**，不用为每个成员都赋值，**_缺少的成员会自动设置为 0_**

```c
int a[2][2] = {[0][0] = 1, [1][1] = 2};
```

- **_不管数组有多少维度，在内存里面都是线性存储_**，a[0][0]的后面是 a[0][1]，a[0][1]的后面是 a[1][0]，以此类推

```c
#include <stdio.h>

int main(int argc, char const *argv[]){
    int nums[2][5] = {
        {1,2,3,4,5},
        {9,8,7,6,5}
    };


    for (int i = 0; i < 2; i++){
        for (int j = 0; j < 5; j++){
            printf("nums[%i][%i] is %i,address is %p\n",i,j,nums[i][j],&nums[i][j]);
        }

    }


    return 0;
}

// 请注意输出的结果，都是连续的
```

> 因此，**多维数组也可以使用单层大括号赋值**，下面的语句与上面的赋值语句是完全等同的

```c
int a[2][2] = {[0][0] = 1, [1][1] = 2};

// 等于

int a[2][2] = {1, 0, 0, 2};

// 空出来的是 0,1 是 1,0
```

- 请注意，在 C 语言中**_定义二维数组，第一个中括号内的数字可省略，而第二个不可省略_**

```c
int nums[] = {566,2};

int nums[][2] = {56,5};

// 原因可以在下面的多维数组参数找到
```

#### 4.变长数组

- 数组声明的时候，**_数组长度除了使用常量，也可以使用变量，这叫做变长数组(variable-length array，简称 VLA)_**

```c
int n = x + y;
int arr[n];

// 上面示例中，数组arr就是变长数组，因为它的长度取决于变量n的值，编译器没法事先确定，只有运行时才能知道n是多少
```

- 变长数组的根本特征，就是**_数组长度只有运行时才能确定_**。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，**_程序可以在运行时为数组分配精确的长度_**
- **_任何长度需要运行时才能确定的数组，都是变长数组_**

```c
int i = 10;

int a1[i];
int a2[i + 5];
int a3[i + k];

// 上面示例中，三个数组的长度都需要运行代码才能知道，编译器并不知道它们的长度，所以它们都是变长数组。
```

- **_变长数组也可以用于多维数组_**

```c
int m = 4;
int n = 5;
int c[m][n];

// 上面示例中，c[m][n]就是二维变长数组
```

#### 5.地址操作

- **_数组是一连串连续储存的同类型值，只要获得起始地址 (首个成员的内存地址)，就能推算出其他成员的地址_**

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int nums[5] = {56,1,89,23,498};
    int *p = &nums[0];

    printf("first of nums is %i\n",*p);
    printf("second of nums is %i\n",*(p+1));
    printf("third of nums is %i\n",*(p+2));

    return 0;
}

// 你可以通过加减地址得到数组中的值，因为他们连续
// 不过注意类型要相同
```

- 由于数组的起始地址是常用操作，&array[0]的写法有点麻烦，C 语言提供了便利写法，**_数组名等同于起始地址_**，也就是说，数组名就是指向第一个成员（array[0]）的指针

```c
int *p;

p = &nums[0];

// 等于

p = nums

if (&nums[0] == nums) // true
```

```c
int nums[];

printf("%p\n",nums);

// 你会直接获得nums的首地址
```

- 这样的话，如果**_把数组名传入一个函数，就等同于传入一个指针变量，在函数内部就可以通过这个指针变量获得整个数组_**

```c
// 函数接受数组作为参数，函数原型可以写成下面这样

// 写法一
int sum(int arr[], int len);
// 写法二
int sum(int* arr, int len);

// 上面示例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号[]与指针符号*是可以互换的
```

> 可以理解为，**_如果指针指向的是一个数组中的第一个值，那么可以直接在他后面索引，或数组名就是一个指向数组起始值的指针_**

```c
#include <stdio.h>


int sum(int* arr, int len){
    //  也可以是int arr[]

    int i;
    int total = 0;

    for (i = 0; i < len; i++){
        total += arr[i];
        total += *(arr+i);

        // 上面两种写法相同
        // 请注意 arr + i 不取值的话出来是地址，所以要取值
    }

    return total;
}


int main(int argc, char const *argv[]){
    int nums[5] = {56,8,23,456,6};

    printf("sum is %i",sum(nums,5));

    return 0;
}
```

> 所以**对于索引数组，我们有这几种写法**

```c
// 获得地址

&nums[i] == (nums + i);

// 获得数据

nums[i] == *(nums + i)
```

- **_"数组"指针并不能完全等于数组名，他无法推出数组长度，也无法在不知道数组长度的前提下遍历数组_**
  > 这里"数组"指针加了一个引号，请注意
- 但是请一定注意一点，**_数组传入函数时会退化为指针_**，所以上面的代码如果想要在函数内部推定数组长度是不可能的
- **_\*和&运算符也可以用于多维数组_**

```c
int a[4][2];

// 取出 a[0][0] 的值

*(a[0]);

// 等同于

**a
```

```c
int nums[2][5] = {
    {1,2,3,4,5},
    {9,8,7,6,5}
};

printf("%i",*(nums[0]));

>>> 1

// 说明取出的是nums[0][0]的值
```

> 由于**a[0]本身是一个指针，指向第二维数组的第一个成员 a[0][0]**。所以，*(a[0])取出的是 a[0][0]的值。至于\*\*a，就是对 a 进行两次*运算，第一次取出的是 a[0]，第二次取出的是 a[0][0]。同理，二维数组的&a[0][0]等同于\*a

- 注意，**_数组名指向的地址是不能更改的_**，声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，下面的代码会报错

```c
int nums[5];

nums = NULL;

// 错误，因为你让他指向了0，改变了地址
```

- 这也导致**_不能将一个数组名赋值给另外一个数组名_**

```c
int a[5] = {1, 2, 3, 4, 5};

// 写法一
int b[5] = a; // 报错

// 写法二
int b[5];
b = a; // 报错

// 因为数组名就是一个指针，你把他再赋给一个数组相当于让他指向另一个地址，这是不行的
```

#### 6.数组指针与指针数组

> 是不是很熟悉这个命名，没错函数指针与指针函数回来了

> 如果你真分不清这些命名，**你只要看最后两个字就行**，函数指针最后一个字是指针说明他是一个指针指向一个函数，指针函数说明他是一个函数返回一个指针

- 再开始介绍之前一定要搞清楚这一章**之前说的指针都不是数组指针**，他只是一个普通的指针，比如下面一会会说到这个指针是可以指出数组范围的，他并没有跟数组关联起来

```c
int nums[5] = {65,24,5,89,56};

int* p = nums;
```

> **p 只是指向了 nums 的首地址，他跟这个数组是无关的**

- **_数组指针，顾名思义指向数组的指针_**，定义语法如下：

```c
int nums[5] = {65,24,5,89,56};

int (*p1)[5] = &nums;
int* p2 = nums;

// 请注意，星号和指针标识符同为于括号内，因为优先级问题不能省略括号，以后在遇见这种格式统统不能省略
// ()与[ ] 优先级相同，根据结合律，就从左向右运算，()里是*p1，先定义了指针，所以p是个指针，然后后面是[ ],才是数组，即数组指针。它指向了含有n个int类型的数组
// 数组指针后面的方括号内数字为数组元素数量，必须相同

// 只能是&nums，不能是nums，因为&nums返回整个数组的位置，nums返回首元素的位置

// p1指向整个数组，p2指向数组首元素

// 好像写成nums也能通过，但是会警告
```

> **_上面的注释看仔细了，一个字都不能差！！！指向数组和指向数组首元素的地址是两码事_**

- 请观察下列代码，分析 p 的指向

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int nums[5] = {65,24,5,89,56};
    int (*p)[5] = &nums;

    for (int i = 0; i < 5; i++){
        printf("nums[%i] is %i\n",i,*(*p + i));
    }

    return 0;
}

// *(*p + 1)是啥？不着急慢慢看
// *p是取出p指向的值，也就是nums
// *p + 1 也就是 nums + 1就是下一小节的加减法索引地址
// 最后加上括号再取值才是整数
```

> 这里再来一个反例你就理解了

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int nums[5] = {65,24,5,89,56};
    int (*p)[5] = &nums;

    for (int i = 0; i < 5; i++){
        printf("nums[%i] is %i\n",i,*(p + i));
    }

    return 0;
}


>>>
nums[0] is 6422000
nums[1] is 6422020
nums[2] is 6422040
nums[3] is 6422060
nums[4] is 6422080


// 你运行一下发现结果都是地址而且都差了20
// 为啥？因为p直接加1相当于加了自己的类型，他是什么类型？
// int数组有五个元素，每一个元素4字节，5*4 = 20
```

> 但是数组指针还是可以引用出自己的范围

- **_指针数组，他是一个数组，但是存储的是指针类型_**

```c
int a = 1,b = 2,c = 3,d = 4,e = 5;

int* p[5] = {&a,&b,&c,&d,&e};

// 一定注意，这里的星号没有括号
```

> 其它它与正常的数组并无区别

```c
int a = 1,b = 2,c = 3,d = 4,e = 5;

int* q[5] = {&a,&b,&c,&d,&e};

for (int i = 0; i < 5; i++){
    printf("p[%i] is %i\n",i,*(p[i]));
}

// 注意不加括号的话 p[i] 取出来的是地址
```

> **二维数组与普通指针**

```c
int a[2][3] = {1, 2, 3, 4, 5, 6};

// 注意之前讲的自动赋值

int *p = a[0];

//a[0]也指向 &a[0][0]，p指向的是二维

printf("%d\n",*(p+3));

// 即使是多维数组，存储上也是连续的，自动跳到下一个了

printf("%d\n",*(*(a+1)));

// *(a + 1)是 a[1]，本身又指向a[1][0]，所以 *(*(a+1)) 是a[1][0]的值

printf("%d\n",p[3]);

// 同理，指针也可以直接索引，多了到下一维

printf("%d\n",a[1][0]);

// 这个总能看懂吧
```

> **二维数组与数组指针**

```c
int a[2][3] = {1, 2, 3, 4, 5, 6};
int (*p)[3] = a;

// 这里a指向的是a[0]，也就是{1,2,3}，正好对应(*p)[3]

printf("%d\n",*(*(p+1)));

// p + 1直接加过{1,2,3}，指向了{4,5,6}，取出*(p + 1)也就是{4,5,6}，本身又指向a[1][0]，所以是4

printf("%d\n",*(*(a+1)));

// 上面讲了

printf("%d\n",p[1][0]);
printf("%d\n",a[1][0]);

// 一个是数过头，一个是正常
```

#### 7.加减法

- C 语言里面，**_数组名 (指向首地址的指针变量) 可以进行加法和减法运算，等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址_**。比如，a + 1 返回下一个成员的地址，a - 1 返回上一个成员的地址
  > **注意是返回地址，不是返回值**，不然你看为啥下面的要加括号再星号

```c
int a[5] = {11, 22, 33, 44, 55};

for (int i = 0; i < 5; i++){
  printf("%d\n", *(a + i));
}
```

> 上面示例中，通过指针的移动遍历数组，a + i 的每轮循环每次都会指向下一个成员的地址，**\*(a + i)取出该地址的值，等同于 a[i]**。对于数组的第一个成员，**\*(a + 0)（即\*a）等同于 a[0]**

```c
int a[6] = { 0,1,2,3,4,5 };
int *p = a;
printf("%d\n", *(a+1));
printf("%d\n", *(p+1));

// 数组名和指向首地址的指针都可以通过加法方式获取成员地址
```

- 由于**_数组名与指针是等价_**的，所以下面的等式总是成立

```c
a[b] == *(a + b)
```

> 上面代码给出了**数组成员的两种访问方式，一种是使用方括号 a[b]，另一种是使用指针\*(a + b)**

- 如果**指针变量 p 指向数组的一个成员，那么 p++就相当于指向下一个成员**，这种方法常用来遍历数组

```c
int nums[] = {89,32,8,65,12,64,7878,0};

int* p = nums;

while (0 != *p){
    printf("%i\n",*p);

    p++;
}

// 注意，数组名指向的地址是不能变的，所以上例中，不能直接对a进行自增，即a++的写法是错的 (但是也可以通过上文的a[b]或*(a + b)，必须将a的地址赋值给指针变量p，然后对p进行自增
```

- 对于二维或多维数组，**_使用 a[n] + m 也能指引分别维度的分别元素地址_**

```c
int numss[2][5] = {
    {65,24,5,89,56},
    {56,2,35,9,7}
};

printf("%i\n",*(numss[0] + 0));
printf("%i\n",*(numss[0] + 1));
printf("%i\n",*(numss[1] + 0));
```

> **也可以用\*(a + n) + m 指引元素地址**

```c
int numss[2][5] = {
    {65,24,5,89,56},
    {56,2,35,9,7}
};

printf("%i\n",*(*(numss + 0) + 0));
printf("%i\n",*(*(numss + 0) + 1));
printf("%i\n",*(*(numss + 1) + 0));

// 一个道理，*(numss + 0)就是取出 numss[0]


if (*(numss + 0) == numss[0]){
    printf("Hello World!\n");
}

// 我寻思 HelloC 里面还没写过 hello world 在这里补上了
```

- 唯一注意一点，**_利用使用二维数组地址时，_(a+i)与 a[i]与 a+1 是等价的\***
  > 应该\*(a + i)是值，a + 1 是地址啊？但是我也不知道为什么

```c
printf("%p\n",numss + 0);
printf("%p\n",*(numss + 0));
printf("%p\n",numss[0]);

// 都是一个地址
// 但是请注意三者是不同类型的
```

- 对于一个二维数组

| 符号    | 类型          | 指向                   |
| ------- | ------------- | ---------------------- |
| &a      | int(\*)[ ][ ] | 指向整个二维数组的地址 |
| a       | int(\*)[ ]    | 指向第一维数组的地址   |
| a[0]    | int(\*)       | 指向第一个元素的地址   |
| a[0][0] | int           | 数值                   |

- **遍历数组一般都是知晓数组长度的比较来实现，但也可以通过数组起始地址和结束地址的比较来实现**

```c
int sum(int* start, int* end) {
    int total = 0;

    while (start < end) {
        total += *start;
        start++;
    }

    return total;
}

int arr[5] = {20, 10, 5, 39, 4};
printf("%i\n", sum(arr, arr + 5));

// 注意这里arr + 5实际上是出了数组的，不知道指的是哪里，但是并没有使用只是比较了内存地址，但还是注意
```

- 反过来，**通过数组的减法，可以知道两个地址之间有多少个数组成员**

```c
int arr[5] = {20, 10, 5, 39, 88};
int* p = arr;

while (*p != 88)
  p++;

  // 这里当p指向39的时候，自己还会自增指向88，然后停止，所以实际上p已经指向了88.不要被迷惑了

printf("%i\n", p - arr);

// 因为第五个与第一个距离4，所以结果是4
```

> 上面示例中，将某个数组成员的地址，减去数组起始地址，就可以知道，当前成员与起始地址之间有多少个成员

- **_同一个数组的两个成员的指针相减时，返回它们之间的距离_**

```c
int* p = &a[5];
int* q = &a[1];

printf("%d\n", p - q); // 4
printf("%d\n", q - p); // -4

// 五号位减一号位，与一号位减五号位
```

- 需要特别注意，对于多维数组，**_数组指针的加减法对于不同维度，含义是不一样的_**

```c
int arr[4][2];

// 指针指向 arr[1]
arr + 1;

// 指针指向 arr[0][1]
arr[0] + 1


// arr是一个二维数组，arr + 1是将指针移动到第一维数组的下一个成员，即arr[1]。由于每个第一维的成员，本身都包含另一个数组，即arr[0]是一个指向第二维数组的指针，所以arr[0] + 1的含义是将指针移动到第二维数组的下一个成员，即arr[0][1]
```

#### 8.复制

- 由于数组名是指针，所以光是简单的复制只是将两个标识符指向同一个变量，还有就是也不能直接复制

```c
int a[] = {56,56,8};
int* b = a;

// 倒是不会报错，但是b也不是数组
```

- 所以复制数组最简单的方法，还是**_使用循环，将数组元素逐个进行复制_**

```c
for (int i = 0,i < count,i++){
    b[i] = a[i];
}

// 多维数组再加一层
```

- 还有一种方法**_使用 memcpy()，定义在 string.h 里，直接将内存数据复制过去_**

```c
#include <string.h>

memcpy(dest,src,n);

// dest:指向目标内存区域的指针
// src:指向源内存区域的指针
// n:要复制的字节数

// 返回参数 dest 的值，即返回一个指向目标内存区域的指针
```

#### 9.函数参数

##### 9.1 声明

- 正如我们上面所说，声明函数参数为数组类型时**既可以为数组指针也可以是数组名**，但是**_必须传入数组长度_**，因为在函数内无法知悉

```c
int func(int arr[],int len)

// 或

int func(int* arr,int len)

// 但是len不能少
```

- **如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义**，也就是**_除了一维参数外其他维度必须写死_**

```c
int sum_array(int a[][4], int n) {
    // ...
}

int a[2][4] = {
    {1, 2, 3, 4},
    {8, 9, 10, 11}
};
int sum = sum_array(a, 2);
```

> 这是因为函数内部拿到的，只是数组的起始地址 a，以及第一维的成员数量 2。如果**要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度**。写成 int a[][4]，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了 4 个整数，所以每个成员的字节长度就是 4 \* sizeof(int)

##### 9.2 变长数组作为参数

- 写法略有不同，**_要事先声明决定数组长度的变量_**

```c
int sum_array(int n, int a[n]) {
    // ...
}

int a[] = {3, 5, 7, 3};
int sum = sum_array(4, a);

// 你必须要先传入数组长度的变量 (也就是n)，在传入变长数组本身，顺序不能乱，这样运行时才能确定数组a[n]
```

- 因为函数原型可以省略参数名，***所以变长数组的原型中，可以使用*代替变量名，也可以省略变量名\***

```c
int func(int,int [*]);

// 或者

int func(int,int [])

// 均合法
```

- 变长数组作为函数参数有一个好处，就是**_多维数组的参数声明，可以把后面的维度省掉了_**

```c
// 原来的写法
int sum_array(int a[][4], int n);

// 变长数组的写法
int sum_array(int n, int m, int a[n][m]);
```

> 上面示例中，函数 sum_array()的参数是一个多维数组，按照原来的写法，一定要声明第二维的长度。但是使用变长数组的写法，就不用声明第二维长度了，因为它可以作为参数传入函数

##### 9.3 数组字面量作为参数

- C 语言**_允许将数组字面量作为参数，传入函数_**

```c
// 数组变量作为参数
int a[] = {2, 3, 4, 5};
int sum = sum_array(a, 4);

// 数组字面量作为参数
int sum = sum_array((int []){2, 3, 4, 5}, 4);
```

> 上面示例中，两种写法是等价的。第二种写法省掉了数组变量的声明，直接将数组字面量传入函数。{2, 3, 4, 5}是数组值的字面量，(int [])类似于强制的类型转换，告诉编译器怎么理解这组值

### 拾壹：字符串

#### 1.概念

- C 语言没有单独的字符串类型，**_字符串被当作字符数组，即 char 类型的数组_**，比如，字符串“Hello”是当作数组{'H', 'e', 'l', 'l', 'o'}处理的
- 编译器会给数组分配一段连续内存，**所有字符储存在相邻的内存单元之中**。在**_字符串结尾，C 语言会自动添加一个全是二进制 0 的字节，写作\0 字符_**，表示字符串结束。字符\0 不同于字符 0，前者的 ASCII 码是 0 (二进制形式 00000000)，后者的 ASCII 码是 48 (二进制形式 00110000)。所以，字符串“Hello”实际储存的数组是{'H', 'e', 'l', 'l', 'o', '\0'}
  > 所有字符串的最后一个字符，都是\0。这样做的好处是，C 语言不需要知道字符串的长度，就可以读取内存里面的字符串，只要发现有一个字符是\0，那么就知道字符串结束了，比如底下的 printf

```c
char localString[10];

// 由于必须留一个位置给\0，所以最多只能容纳9个字符的字符串。
```

- 字符串写成数组的形式，是非常麻烦的。C 语言提供了一种简写法，**_双引号之中的字符，会被自动视为字符数组_**

```c
char hello[] = {'H', 'e', 'l', 'l', 'o', '\0'}

// 等价于

"Hello"

// 注意是双引号不是单引号，单引号是字符，双引号是字符串，一定不能混
// 双引号里面的字符串，不用自己添加结尾字符\0，C 语言会自动添加
```

> 注意在使用双引号自动赋值时不用考虑，但是在花括号单独赋值时不能落下 _\0_

```c
char hello[] = "Hello"

// 实际为

char hello[] = {'H','e','l','l'.'o','\0'};

// 但是不能是

char hello[] = {'H','e','l','l'.'o'};  // 错误
```

> 即使**双引号里面只有一个字符 (比如"a")，也依然被处理成字符串 (存储为 2 个字节)**，*注：占两个字节因为还有一个结束符*而不是字符'a'(存储为 1 个字节)

- **_包含特殊字符需要反斜杠转义，也可以包含特殊的转义字符如换行符_**

```c
char hello[] = "Hello \"Peter\" ! \n";
```

- 字符串过长**_也可以使用反斜杠跨行_**，不过**反斜杠后面不能有空格**不然会以为是转义

```c
char hello[] = "hello \
world";

// 没错，必须顶格不支持缩进，不然的话空格也会被算进去
```

- C 语言允许合并多个字符串字面量，只要这些**_字符串之间没有间隔，或者只有空格，C 语言会将它们自动合并_**

```c
char hello[] = "hello" "world" "java";

// 等于

char hello[] = "helloworldjava"
```

> 这样就可以跨行缩进字符串了

```c
char hello[] = "hello"
    "world"
    "java";

// 别忘了分号
```

- printf**_打印字符串使用 %s 占位符_**

```c
printf("%s\n",hello);
```

#### 2.字符串变量的声明

- **_字符串变量可以声明成一个字符数组，也可以声明成一个指针，指向字符字面量_**
  > 无论如何 "Hello" 都是一个 char[4] 的类型，用指针是指向这个字符串字面量的第一个字节，用数组是拷贝了一份存储在栈空间

```c
// 写法一
char s[14] = "Hello, world!";

// 写法二
char* s = "Hello, world!";

// 没错字符指针可以直接指向字面量
```

- 由于字符数组的长度可以让编译器自动计算，所以**_声明时可以省略字符数组的长度_**

```c
char s[] = "Hello, world!";
```

- **_字符数组的长度，可以大于字符串的实际长度，后面空出来的位置，都会被初始化为\0，但是不能小于字符串的实际长度_**

```c
char s = [100] = "Hello!";

// 后面都是 \0

char string[5] = "Hello";

// 注意只有五个字符的话是容不下 \0 的，如果打印的话会出现一些意想不到的结果

char s[5] = "hello";
printf("%s\n",s);

>>> hello??

// 挺有意思
```

- 字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，但是有两个差异：

1. **_指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身_**

```c
char* s = "Hello World!";

s[0] = 'h';
*s = 'h';

// 报错
// 很奇怪编译能通过，但是执行不了
```

- 如果使用数组声明字符串变量，就没有这个问题，**_可以修改数组的任意成员_**

```c
char s[] = "Hello World!";

s[0] = 'h';
```

> 为什么字符串声明为指针时不能修改，声明为数组时就可以修改？原因是系统会将**字符串的字面量 (常量)保存在内存的常量区**，也叫字符串字面量池，这个区是不允许用户修改的。声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此**用户不能通过这个地址去修改常量区**。但是，声明为数组时，**编译器会给数组单独分配一段内存**，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的

- 为了提醒用户，字符串声明为指针后不得修改，**可以在声明时使用 const 说明符，保证该字符串是只读的**

```c
const char* s = "Hello World!";

// 这是常量指针
```

2. **_指针变量可以指向其它字符串，但是数组不行_**

```c
// 通过

char* s = "Hello";
s = "Hallo";

// 报错

char s[] = "Hello";
s[] = "Hallo";
```

- **_字符数组的数组名，总是指向初始化时的字符串地址，不能修改，同样的原因，声明字符数组后，不能直接用字符串赋值_**

```c
char s[];

s = "Hello";

// 报错，表达式必须是可修改的左值
```

> **字符数组的变量名，跟所指向的数组是绑定的，不能指向另一个地址**。为什么数组变量不能赋值为另一个数组？原因是数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，**数组变量是一个不可修改的左值**，即不能用赋值运算符为它重新赋值

#### 3.字符串数组

- 如果**_一个数组的每个成员都是一个字符串，需要通过二维的字符数组实现。每个字符串本身是一个字符数组，多个字符串再组成一个数组_**

```c
char name[3][6] = {
    "peter",
    "tom",
    "jamie"
};

// name是一个字符串数组，里面有七个元素，每个元素又是一个字符串数组
// 其中最长的字符串长度是6 (包含 \0) 所以只能同意设为 6，多余的设为 0
// 跟之前的数组一样，第一维的长度编译器可以自动推导，其他维度不可以

char name[][6] = {
    "peter",
    "tom",
    "jamie"
};

// 但是这样有一点浪费空间，多余的只能用 \0 填充
```

> 还记得我们之前讲过的指针数组吗？

```c
int a1[]={11,12,13,14};
int a2[]={21,22,23};
int a3[]={31,32,33,34,35};
int * arr[]={a1,a2,a3};
printf("%d",arr[1][2]);
```

- 同理，我们**_可以声明一个字符串指针数组，每一个字符串字面量当作指针存储进去_**

```c
char* string[] = {
    "Hello",
    "World",
    "Java"
};

// 也可以遍历

for (int i = 0; i < 3; i++){
    printf("string[%i] is %s\n",i,string[i]);
}
```

#### 4.字符串的操作

> 注：**下列所有函数定义在头文件 <string.h> 里**

```c
#import <string.h>
```

##### 4.1 strlen()

- 在头文件 <string.h> 里有一个**_strlen 函数，接受一个字符串变量，返回一个字符串字节长度 (不包含 \0)的 size_t 无符号整数_** (除非长度特长，一般照 int 对待没问题)，原型如下

```c
// string.h

char * strcpy(char *dst,const char *src)
{
    if((dst==NULL)||(src==NULL))

           return NULL;

    char *ret = dst;

    while ((*dst++=*src++)!='\0');

    return ret;
}
```

> 使用如下

```c
char* s = "Hello";
int len = strlen(s);
printf("length of string is %i\n",len);
```

- 注意，**_字符串长度 (strlen() )与字符串变量长度 (sizeof() )，是两个不同的概念_**

```c
char s[50] = "Hello";
printf("strlen is %zd\n",strlen(s));    // 5
printf("sizeof is %zd\n",sizeof(s));    // 50

// 一个忽略 \0 一个不忽略
```

- 当然**_也可以通过判断结尾的 _\0* 自己判断字符串长度***

```c
int strlenth(char* s){
    int i = 0;

    while(s[i] != '\0'){
        i++;
    }

    return i;
}

printf("strlenth is %i\n",strlenth(s));

// 这里注意 '\0' 是一个字符而不是字符串
```

##### 4.2 strcpy() 和 strncpy()

- **字符串的复制，不能使用赋值运算符，直接将一个字符串赋值给字符数组变量**

```c
char str1[10];
char str2[10];

str1 = "abc"; // 报错
str2 = str1;  // 报错
```

- 如果是**字符指针，赋值运算符 = 只是将一个指针的地址复制给另一个指针，而不是复制字符串**

```c
char* s1;
char* s2;

s1 = "abc";
s2 = s1;

// 上面代码可以运行，结果是两个指针变量s1和s2指向同一字符串，而不是将字符串s1的内容复制给s2，修改s1导致s2也会变
```

- **_C 语言提供了 strcpy()函数，用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。该函数的原型定义在 string.h 头文件里面_**

```c
// string.h
strcpy(char dest[], const char source[])
```

- strcpy()接受两个参数，**_第一个参数是目的字符串数组，第二个参数是源字符串数组_**。复制字符串之前，必须要保证**_第一个参数的长度不小于第二个参数_**，否则虽然不会报错，但会溢出第一个字符串变量的边界，发生难以预料的结果。第二个参数的 const 说明符，表示这个函数**_不会修改第二个字符串_**

```c
char s3[] = "Hello";
char s4[6];

// 这里注意s4必须先定义长度，不然编译器没法分配s4

strcpy(s4,s3);

printf("s4 is %s",s4);
```

> 问题如下的输出是什么

```c
char s5[] = "ABCDEF";
char s6[] = "abc";

strcpy(s5,s6);
printf("s6 is %s\n",s5);

>>> abc
```

> strcpy 应该复制到\0 就不复制了，为什么不是 abc\0DEF，是因为 **strcpy 不仅复制字符还复制\0**，所以打印时读到 \0 就不打印了，**后面的浪费了**，后面有一个 strncpy 可以解决以下问题

- **strcpy 接受的第二参数可以是字面量，所以也可以用于字符数组的赋值**

```c
char str[10];
strcpy(str, "abcd");
```

- **_strcpy()的返回值是一个字符串指针 (即 char_)，指向第一个参数\***

```c
char* s1 = "beast";
char s2[40] = "Be the best that you can be.";
char* ps;

ps = strcpy(s2 + 7, s1);

// 跟数组一样，这个也可以指定位置复制

puts(s2); // Be the beast

// 这里其实后面的还有内容，但是一个 \0 就浪费了

puts(ps); // beast
```

- strcpy()返回值的另一个用途，是**连续为多个字符数组赋值**

```c
strcpy(str1, strcpy(str2, "abcd"));

// 上面示例调用两次strcpy()，完成两个字符串变量的赋值
```

- **strcpy()的第一个参数最好是一个已经声明的数组，而不是声明后没有进行初始化的字符指针**

```c
char* str;
strcpy(str, "hello world"); // 错误

// strcpy()将字符串分配给指针变量str，但是str并没有进行初始化，指向的是一个随机的位置，因此字符串可能被复制到任意地方。
```

- 如果不用 strcpy()，自己实现字符串的拷贝，可以用下面的代码。

```c
char* strcopy(char* dest, const char* source) {
    char* ptr = dest;
    while (*dest++ = *source++);
    return ptr;
}

int main(void) {
    char str[25];
    strcopy(str, "hello world");
    printf("%s\n", str);
    return 0;
}


// 上面代码中，关键的一行是while (*dest++ = *source++)，这是一个循环，依次将source的每个字符赋值给dest，然后移向下一个位置，直到遇到\0，循环判断条件不再为真 (非零均为真，\0也是假)，从而跳出循环。其中，*dest++这个表达式等同于*(dest++)，即先返回dest这个地址，再进行自增运算移向下一个位置，而*dest可以对当前位置赋值
```

> **strcpy()函数有安全风险**，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。如果不能保证不会发生溢出，建议使用 strncpy()函数代替

- **_strncpy()_**
- strncpy()跟 strcpy()的用法完全一样，只是多了**_第 3 个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界_**

```c
char* strncpy(char* dest, char* src, size_t n);

// 第三个参数n定义了复制的最大字符数。如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的字符串结尾将没有终止符\0，这一点务必注意。如果源字符串的字符数小于n，则strncpy()的行为与strcpy()完全一致
```

- 一定注意，**使用 strncpy 不会加入结束符，所以一定要自己写上**

```c
strncpy(str1, str2, sizeof(str1) - 1);
str1[sizeof(str1) - 1] = '\0';
```

> 上面示例中，字符串 str2 复制给 str1，但是**复制长度最多为 str1 的长度减去 1**，str1 剩下的**最后一位用于写入字符串的结尾标志\0**。这是因为 strncpy()不会自己添加\0，如果复制的字符串片段不包含结尾标志，就需要手动添加

- **一般 strncpy()用来拷贝部分字符串**

```c
char s1[40];
char s2[12] = "hello world";

strncpy(s1, s2, 5);
s1[5] = '\0';

printf("%s\n", s1); // hello

// 指定只拷贝前5个字符
```

##### 4.3 strcat() 和 strncat()

- **_strcat()函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾_**。这个函数会改变第一个字符串，但是第二个字符串不变
  > 该函数的原型定义在**string.h 头文件**里面。

```c
char* strcat(char* s1, const char* s2);
```

> **strcat()的返回值是一个字符串指针，指向第一个参数**

```c
char s1[12] = "hello";
char s2[6] = "world";

strcat(s1, s2);
puts(s1); // "helloworld"

// 调用strcat()以后，可以看到字符串s1的值变了。
```

> 注意，**_strcat()的第一个参数的长度，必须足以容纳添加第二个参数字符串_**。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元，这是很危险的，建议使用下面的 strncat()代替

- **strncat()用于连接两个字符串，用法与 strcat()完全一致，只是增加了第三个参数，指定最大添加的字符数**。在添加过程中，一旦**达到指定的字符数，或者在源字符串中遇到空字符\0，就不再添加了**。它的**原型定义在 string.h 头文件**里面

```c
char* strncat(
    const char* dest,
    const char* src,
    size_t n
);
```

> **strncat()返回第一个参数，即目标字符串指针**

- 为了保证连接后的字符串，不超过目标字符串的长度，strncat()通常会写成下面这样

```c
strncat(
    str1,
    str2,
    sizeof(str1) - strlen(str1) - 1
);
```

> strncat()总是会在拼接结果的结尾，自动添加空字符\0，所以第三个参数的最大值，应该是 str1 的**变量长度减去 str1 的字符串长度，再减去 1**。下面是一个用法实例

```c
char s1[10] = "Monday";
char s2[8] = "Tuesday";

strncat(s1, s2, 3);
puts(s1); // "MondayTue"
```

> 上面示例中，s1 的变量长度是 10，字符长度是 6，两者相减后再减去 1，得到 3，表明 s1 最多可以再添加三个字符，所以得到的结果是 MondayTue

##### 4.4 strcmp() 和 strncmp()

- 如果要比较两个字符串，无法直接比较，只能一个个字符进行比较，C 语言提供了**_strcmp()函数用于比较两个字符串_**
  > 该函数的原型如下，**定义在 string.h 头文件**里面

```c
int strcmp(const char* s1, const char* s2);
```

- 按照字典顺序，**如果两个字符串相同，返回值为 0；如果 s1 小于 s2 (ASCII 码)，strcmp()返回值小于 0；如果 s1 大于 s2，返回值大于 0**

```c
char s1[] = "Happy New Year"
char s2[] = "Happy New Year"
char s3[] = "Happy Holidays"

strcmp(s1, s2) // 0
strcmp(s1, s3) // 大于 0
strcmp(s3, s1) // 小于 0

// strcmp() 会根据 ASCII 编码依次比较 str1 和 str2 的每一个字符，直到出现不到的字符，或者到达字符串末尾 (遇见\0)
// 注意，C语言标准并没有具体规定 strcmp() 函数的返回值是多少，大多数编译器选择了以下两种方案
// 1. 返回两个字符串的差值，即找到两个字符串中首个不相等的字符，然后返回这两个字符的差值；
// 2. 返回 -1、0 或者 +1
```

> 注意，**strcmp()只用来比较字符串，不用来比较字符**。因为字符就是小整数，直接用相等运算符（==）就能比较。所以，不要把字符类型（char）的值，放入 strcmp()当作参数

- 由于 strcmp()比较的是整个字符串，C 语言又提供了**_strncmp()函数，只比较到指定的位置_**，该函数增加了**第三个参数，指定了比较的字符数**

```c
int strncmp(
    const char* s1,
    const char* s2,
    size_t n
);
```

- **它的返回值与 strcmp()一样**。如果两个字符串相同，返回值为 0；如果 s1 小于 s2，strcmp()返回值小于 0；如果 s1 大于 s2，返回值大于 0。

```c
char s1[12] = "hello world";
char s2[12] = "hello C";

if (strncmp(s1, s2, 5) == 0) {
  printf("They all have hello.\n");
}

// 只比较两个字符串的前5个字符
```

##### 4.5 sprintf() 和 snprintf()

- **_sprintf()函数跟 printf()类似，但是用于将数据写入字符串，而不是输出到显示器_**

```c
int sprintf(char* s, const char* format, ...);
```

- sprintf()的**第一个参数是字符串指针变量，其余参数和 printf()相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表**

```c
char first[6] = "hello";
char last[6] = "world";
char s[40];

sprintf(s, "%s %s", first, last);

printf("%s\n", s); // hello world

// sprintf()将输出内容组合成 hello world ，然后放入了变量s
```

- sprintf()的**_返回值是写入变量的字符数量 (不计入尾部的空字符\0) 。如果遇到错误，返回负值_**
  > sprintf()有严重的安全风险，**如果写入的字符串过长，超过了目标字符串的长度，sprintf()依然会将其写入，导致发生溢出**。为了控制写入的字符串的长度，C 语言又提供了另一个函数 snprintf()
- **_snprintf()只比 sprintf()多了一个参数 n，用来控制写入变量的字符串不超过 n - 1 个字符，剩下一个位置写入空字符\0_**

```c
int snprintf(char*s, size_t n, const char* format, ...);
```

- **snprintf()总是会自动写入字符串结尾的空字符**。如果你**尝试写入的字符数超过指定的最大字符数，snprintf()会写入 n - 1 个字符，留出最后一个位置写入空字符**

```c
snprintf(s, 12, "%s %s", "hello", "world");
```

- **_snprintf()的返回值是写入格式字符串的字符数量 (不计入尾部的空字符\0)_**。如果 n 足够大，返回值应该小于 n，但是有时候**格式字符串的长度可能大于 n，那么这时返回值会大于 n，但实际上真正写入变量的还是 n-1 个字符**。如果遇到错误，返回一个负值。因此，**_返回值只有在非负并且小于 n 时，才能确认完整的格式字符串写入了变量_**

##### 4.6 memset()

- **memset 函数用于对数据进行初始化**，比如字符串统一赋值为 0

```c
#include <string.h>

void *memset(void *str, int c, size_t n)
```

- **复制字符 c (一个无符号字符)到参数 str 所指向的字符串的前 n 个字节**
  > 但是需要注意的是**memset 赋值的时候是按字节赋值，是将参数化成二进制之后填入一个字节**
- 所以赋值为 0 没问题，赋值为具体的值就有问题了

```c
int n[] = {1,2,3,4,5};
memset(n,100,sizeof(n));
for (int i = 0; i < 5; i++){
        printf("%i\n",n[i]);
}

// 打印你会发现并不是100而是一个不知道的值
```

#### 5.多字节字符

##### 5.1 简介

> **C 语言诞生时，只考虑了英语字符**，使用 7 位的 ASCII 码表示所有字符。ASCII 码的范围是 0 到 127，也就是最多只能表示 100 多个字符，用一个字节就可以表示，所以 char 类型只占用一个字节  
>  但是，如果**处理非英语字符，一个字节就不够了**，单单是中文，就至少有几万个字符，字符集就势必使用多个字节表示  
>  最初，不同国家有自己的字符编码方式，这样不便于多种字符的混用。因此，后来就逐渐统一到 **Unicode 编码，将所有字符放入一个字符集**  
>  **Unicode 为每个字符提供一个号码，称为码点 (code point)**，其中 0 到 127 的部分，跟 ASCII 码是重合的。通常使用"U+十六进制码点"表示一个字符，比如 U+0041 表示字母 A  
>  Unicode 编码目前一共包含了 100 多万个字符，码点范围是 U+0000 到 U+10FFFF。完整表达整个 Unicode 字符集，至少需要三个字节。但是，并不是所有文档都需要那么多字符，比如对于 ASCII 码就够用的英语文档，如果每个字符使用三个字节表示，就会比单字节表示的文件体积大出三倍  
>  为了适应不同的使用需求，**Unicode 标准委员会提供了三种不同的表示方法，表示 Unicode 码点**:

1. **UTF-8**：使用 1 个到 4 个字节，表示一个码点。不同的字符占用的字节数不一样。
2. **UTF-16**：对于 U+0000 到 U+FFFF 的字符（称为基本平面），使用 2 个字节表示一个码点。其他字符使用 4 个字节。
3. **UTF-32**：统一使用 4 个字节，表示一个码点
   > 其中，**UTF-8 的使用最为广泛，因为对于 ASCII 字符（U+0000 到 U+007F），它只使用一个字节表示，这就跟 ASCII 的编码方式完全一样**

- **C 语言提供了两个宏，表示当前系统支持的编码字节长度**。这两个宏都定义在头文件 limits.h
  > MB_LEN_MAX：任意支持地区的最大字节长度，定义在 limits.h  
  > MB_CUR_MAX：当前语言的最大字节长度，总是小于或等于 MB_LEN_MAX，定义在 stdlib.h

##### 5.2 表示方法

- **_字符表示法的本质，是将每个字符映射为一个整数，然后从编码表获得该整数对应的字符_**
  > C 语言提供了不同的写法，用来表示字符的整数号码

1. \123：以八进制值表示一个字符，斜杠后面需要三个数字。
2. \x4D：以十六进制表示一个字符，\x 后面是十六进制整数。
3. \u2620：以 Unicode 码点表示一个字符 (不适用于 ASCII 字符)，码点以十六进制表示，\u 后面需要 4 个字符。
4. \U0001243F：以 Unicode 码点表示一个字符 (不适用于 ASCII 字符)，码点以十六进制表示，\U 后面需要 8 个字符

##### 5.3 多字节字符的表示

- C 语言**预设只有基本字符，才能使用字面量表示**，**_其它字符都应该使用码点表示，并且当前系统还必须支持该码点的编码方法_**
  > 所谓基本字符，指的是所有可打印的 ASCII 字符，但是**_有三个字符除外： @ \$ `_**
- 因此，**_遇到非英语字符，应该将其写成 Unicode 码点形式_**

```c
char* s = "\u6625\u5929";
printf("%s\n", s); // 春天
```

- **_如果当前系统是 UTF-8 编码，可以直接用字面量表示多字节字符_**

```c
char* s = "春天";
printf("%s\n", s);

// 注意，\u + 码点和\U + 码点的写法，不能用来表示 ASCII 码字符 (码点小于0xA0的字符) ，只有三个字符除外：0x24 $ ，0x40 @ 和 0x60 `

char* s = "\u0024\u0040\u0060";
printf("%s\n", s);  // @$`

// 上面代码会输出三个 Unicode 字符 @ $ ` ，但是其它 ASCII 字符都不能用这种表示法表示
```

- 但是 Windows 用户请注意，cmd 控制台默认输出为 GBK 格式，中文会乱码，解决办法

```c
// 引入windows.h头文件修改控制台输出格式

#include <stdio.h>
#include <windows.h>

int main(void){
    SetConsoleOutputCP(65001);
    char* s = "\u4f60\u597d\u4e16\u754c";
    printf("%s\n", s);

    return 0;
}
```

> 为了保证程序执行时，字符能够正确解读，**最好将程序环境切换到本地化环境**

```c
setlocale(LC_ALL, "");

// 使用setlocale()切换执行环境到系统的本地化语言。setlocale()的原型定义在头文件locale.h

// 像下面这样，指定编码语言也可以

setlocale(LC_ALL, "zh_CN.UTF-8");

// 上面代码将程序执行环境，切换到中文环境的 UTF-8 编码
```

- **_C 语言允许使用 u8 前缀，对多字节字符串指定编码方式为 UTF-8_**

```c
char* s = u8"春天";
printf("%s\n", s);

// 一旦字符串里面包含多字节字符，就意味着字符串的字节数与字符数不再一一对应了。比如，字符串的长度为10字节，就不再是包含10个字符，而可能只包含7个字符、5个字符等等

setlocale(LC_ALL, "");

char* s = "春天";
printf("%d\n", strlen(s)); // 6

// 字符串s只包含两个字符，但是strlen()返回的结果却是6，表示这两个字符一共占据了6个字节
```

- **_C 语言的字符串函数只针对单字节字符有效，对于多字节字符都会失效_**，比如 strtok()、strchr()、strspn()、toupper()、tolower()、isalpha()等不会得到正确结果

##### 5.4 宽字符

- **多字节字符串，每个字符的字节宽度是可变的**。这种编码方式虽然使用起来方便，但是很不利于字符串处理，因此必须逐一检查每个字符占用的字节数。所以除了这种方式，**_C 语言还提供了确定宽度的多字节字符存储方式，称为宽字符 (wide character)_**
- 所谓**_宽字符就是每个字符占用的字节数是固定的_**，要么是 2 个字节，要么是 4 个字节。这样的话，就很容易快速处理。
- **宽字符有一个单独的数据类型 wchar_t，每个宽字符都是这个类型**。它属于整数类型的别名，可能是有符号的，也可能是无符号的，由当前实现决定。该类型的长度为 16 位 (两字节) 或 32 位 (四字节) ，足以容纳当前系统的所有字符。**它定义在头文件 wchar.h 里面**
- **_宽字符的字面量必须加上前缀 L_**，否则 C 语言会把字面量当作窄字符类型处理

```c
setlocale(LC_ALL, "");

wchar_t c = L'牛'；
printf("%lc\n", c);

wchar_t* s = L"春天";
printf("%ls\n", s);

// 上面示例中，前缀 L 在单引号前面，表示宽字符，对应printf()的占位符为%lc；在双引号前面，表示宽字符串，对应printf()的占位符为%ls
```

- **_宽字符串的结尾也有一个空字符，不过是宽空字符，占用多个字节_**
- **_处理宽字符，需要使用宽字符专用的函数，绝大部分都定义在头文件 wchar.h_**

##### 5.5 多字节字符处理函数

###### 5.5.1 mblen()

- **_mblen()函数返回一个多字节字符占用的字节数_**。它的原型定义在**头文件 stdlib.h**

```c
int mblen(const char* mbstr, size_t n);
```

- 它接受两个参数，**_第一个参数是多字节字符串指针，一般会检查该字符串的第一个字符；第二个参数是需要检查的字节数，这个数字不能大于当前系统单个字符占用的最大字节，一般使用 MB_CUR_MAX_**
- **_它的返回值是该字符占用的字节数。如果当前字符是空的宽字符，则返回 0；如果当前字符不是有效的多字节字符，则返回-1_**

```c
setlocale(LC_ALL, "");

char* mbs1 = "春天";
printf("%d\n", mblen(mbs1, MB_CUR_MAX)); // 3

char* mbs2 = "abc";
printf("%d\n", mblen(mbs2, MB_CUR_MAX)); // 1

// 字符串春天的第一个字符春，占用3个字节；字符串 abc 的第一个字符 a ，占用1个字节
```

###### 5.5.2 wctomb()

- **_wctomb()函数 (wide character to multibyte)用于将宽字符转为多字节字符_**。它的原型定义在**头文件 stdlib.h**

```c
int wctomb(char* s, wchar_t wc);
```

- **_wctomb()接受两个参数，第一个参数是作为目标的多字节字符数组，第二个参数是需要转换的一个宽字符。它的返回值是多字节字符存储占用的字节数量，如果无法转换，则返回-1_**

```c
setlocale(LC_ALL, "");

wchar_t wc = L'牛';
char mbStr[10] = "";

int nBytes = 0;
nBytes = wctomb(mbStr, wc);

printf("%s\n", mbStr);  // 牛
printf("%d\n", nBytes);  // 3

// wctomb()将宽字符 牛 转为多字节字符，wctomb()的返回值表示转换后的多字节字符占用3个字节
```

###### 5.5.3 mbtowc()

- **_mbtowc()用于将多字节字符转为宽字符。它的原型定义在头文件 stdlib.h_**

```c
int mbtowc(
    wchar_t* wchar,
    const char* mbchar,
    size_t count
);
```

- **_它接受 3 个参数，第一个参数是作为目标的宽字符指针，第二个参数是待转换的多字节字符指针，第三个参数是多字节字符的字节数_**
- **它的返回值是多字节字符的字节数，如果转换失败，则返回-1**

```c
setlocale(LC_ALL, "");

char* mbchar = "牛";
wchar_t wc;
wchar_t* pwc = &wc;

int nBytes = 0;
nBytes = mbtowc(pwc, mbchar, 3);

printf("%d\n", nBytes); // 3
printf("%lc\n", *pwc);  // 牛

// mbtowc()将多字节字符 牛 转为宽字符wc，返回值是mbchar占用的字节数 (占用3个字节)
```

###### 5.5.4 wcstombs()

- **_wcstombs()用来将宽字符串转换为多字节字符串。它的原型定义在头文件 stdlib.h_**

```c
size_t wcstombs(
    char* mbstr,
    const wchar_t* wcstr,
    size_t count
);
```

- **_它接受三个参数，第一个参数 mbstr 是目标的多字节字符串指针，第二个参数 wcstr 是待转换的宽字符串指针，第三个参数 count 是用来存储多字节字符串的最大字节数_**
- **如果转换成功，它的返回值是成功转换后的多字节字符串的字节数，不包括尾部的字符串终止符；如果转换失败，则返回-1**

```c
setlocale(LC_ALL, "");

char mbs[20];
wchar_t* wcs = L"春天";

int nBytes = 0;
nBytes = wcstombs(mbs, wcs, 20);

printf("%s\n", mbs); // 春天
printf("%d\n", nBytes); // 6
// wcstombs()将宽字符串wcs转为多字节字符串mbs，返回值6表示写入mbs的字符串占用6个字节，不包括尾部的字符串终止符。
```

- **如果 wcstombs()的第一个参数是 NULL，则返回转换成功所需要的目标字符串的字节数**

###### 5.5.5 mbstowcs()

- **_mbstowcs()用来将多字节字符串转换为宽字符串。它的原型定义在头文件 stdlib.h_**

```c
size_t mbstowcs(
    wchar_t* wcstr,
    const char* mbstr,
    size_t count
);
```

- **_它接受三个参数，第一个参数 wcstr 是目标宽字符串，第二个参数 mbstr 是待转换的多字节字符串，第三个参数是待转换的多字节字符串的最大字符数_**
- **转换成功时，它的返回值是成功转换的多字节字符的数量；转换失败时，返回-1。如果返回值与第三个参数相同，那么转换后的宽字符串不是以 NULL 结尾的**

```c
setlocale(LC_ALL, "");

char* mbs = "天气不错";
wchar_t wcs[20];

int nBytes = 0;
nBytes = mbstowcs(wcs, mbs, 20);

printf("%ls\n", wcs); // 天气不错
printf("%d\n", nBytes); // 4

// 多字节字符串mbs被mbstowcs()转为宽字符串，成功转换了4个字符，所以该函数的返回值为4
```

- **如果 mbstowcs()的第一个参数为 NULL，则返回目标宽字符串会包含的字符数量**
  > 注：上面所有函数均未个人尝试，要了解的时候再修订

### 拾贰：变量说明符

- C 语言允许声明变量的时候，加上一些特定的说明符 (specifier)，为编译器提供变量行为的额外信息，之前我们简单了解过 extern 和 static，这里再来介绍几个

#### 1.auto

- **_auto 说明符表示该变量的存储，由编译器自主分配内存空间，且只存在于定义时所在的作用域，退出作用域时会自动释放_**
- 由于只要不是 extern 的变量（外部变量），都是由编译器自主分配内存空间的，这属于默认行为，所以**该说明符没有实际作用，一般都省略不写**

```c
auto int a;
// 等同于
int a;
```

#### 2.register

- **_register 说明符向编译器表示，该变量是经常使用的，应该提供最快的读取速度，所以应该放进寄存器_**。但是，编译器可以忽略这个说明符，**不一定按照这个指示行事**

```c
register int a;
```

- **_register 只对声明在代码块内部的变量有效_**
- **_设为 register 的变量，不能获取它的地址_**

```c
register int a;
int *p = &a; // 编译器报错

// 变量a可能放在寄存器里面，无法获取内存地址。
```

- **_如果数组设为 register，也不能获取整个数组或任一个数组成员的地址_**

```c
register int a[] = {11, 22, 33, 44, 55};

int p = a;  // 报错
int a = *(a + 2); // 报错
```

- **_CPU 内部的缓存，称为寄存器 (register，也就是一级二级三级缓存)_**。与内存相比，**_寄存器的访问速度快得多_**，所以使用它们可以提高速度。但是它们不在内存之中，所以**_没有内存地址_**，这就是为什么不能获取指向它们的指针地址。现代编译器已经有巨大的进步，会尽可能优化代码，按照自己的规则决定怎么利用好寄存器，取得最佳的执行速度，所以**可能会忽视代码里面的 register 说明符，不保证一定会把这些变量放到寄存器**

#### 3.restrict

- **_restrict 说明符允许编译器优化某些代码。它只能用于指针，表明该指针是访问数据的唯一方式_**

```c
int* restrict pt = (int*) malloc(10 * sizeof(int));

// restrict表示变量pt是访问 malloc 所分配内存的唯一方式，malloc是什么马上会讲

// 由于数组的特性，就不能使用restrict说明符

int foo[10];
int* bar = foo;

// 变量foo指向的内存，可以用foo访问，也可以用bar访问，因此就不能将foo设为 restrict
```

- 如果编译器知道某块内存只能用一个方式访问，可能可以更好地优化代码，因为不用担心其他地方会修改值
- **_restrict 用于函数参数时，表示参数的内存地址之间没有重叠_**

```c
void swap(int* restrict a, int* restrict b) {
    int t;
    t = *a;
    *a = *b;
    *b = t;
}

// 函数参数声明里的restrict表示，参数a和参数b的内存地址没有重叠
```

### 拾叁：多文件项目

> 之前在 extern 那节简单介绍了以下多文件的编译过程，这里进行一下详细讲解，重复的话会略过

- 很多时候源码为了方便管理是多文件状态，那么就有必要了解下多文件的编译过程
  > 对于外部的变量或者函数，你不声明的话编译器是不知道的，所以有两种办法引入外部函数或变量

```c
// 1.声明外部函数原型再在命令行传入外部文件的地址

extern int add(int,int);
// 不些extern也可以
int add(int,int);

extern int nums[];

// extern说明符告诉编译器，数组nums是其他脚本文件声明的，不需要在这里为它分配内存空间
// 由于不需要分配内存空间，所以extern声明数组时，不需要给出数组长度

$ gcc a.c b.c

// 2.外部作为库引入，使用 < > 符号(系统自带) 和 " " 符号(自定义)

#include <stdio.h>
#include "a.h"
```

## 第三章：内存与结构

### 拾肆：内存管理

#### 1.概念

- C 语言的内存管理，分成两部分。**一部分是系统管理的，另一部分是用户手动管理的**
- 首先简单回顾几种变量：

1. **全局变量 (外部变量)**：出现在*代码块{}之外的变量*就是全局变量。
2. **局部变量 (自动变量)**：一般情况下，*代码块{}内部定义的变量*就是自动变量
3. **静态变量**：_是指内存位置在程序执行期间一直不改变的变量，用关键字 static 修饰_。代码块内部的静态变量只能被这个代码块内部访问，代码块外部的静态变量只能被定义这个变量的文件访问
   > extern 修饰变量时，根据具体情况，既可以看作是定义也可以看作是声明；但 extern 修饰函数时只能是定义

- 系统管理的内存，主要是**函数内部的变量 (局部变量)**。这部分变量在函数运行时进入内存，**函数运行结束后自动从内存卸载**。这些变量存放的区域称为 _栈 stack_，**栈所在的内存是系统自动管理的**
- 用户手动管理的内存，主要是**程序运行的整个过程中都存在的变量 (全局变量)**，这些变量需要用户手动从内存释放。**如果使用后忘记释放，它就一直占用内存**，直到程序退出，**这种情况称为"内存泄漏"** (memory leak)。这些变量所在的内存称为 _堆 heap_，**堆所在的内存是用户手动管理的**
- 请看如下的内存模型：

```c
// 注，Windows，Linux以及不同的系统内存模型不尽相同，这里只是简单介绍重要段

|------| --> 0000 // 低位，注意不同的内存大小这里的地位数字不同，这里只是举例
   ···
|------|
| stack| --> // 栈区，stack
| area | --> // 栈是一种先进后出的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们写程序时不需要考虑
|      | --> // 每个线程都有自己专属的栈，栈的最大尺寸固定，超出则引起栈溢出，变量离开作用域后栈上的内存会自动释放
|  ↓   | --> // 栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，自动从栈中弹出
|  ↓   | --> // 从上往下存储，先进后出
|  ↓   |
|      |
|------|
| Heap | --> // 堆（heap）和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序
| area | --> // 更重要的是堆是一个大容器，它的容量要远远大于栈，这可以解决上面实验三造成的内存溢出困难。一般比较复杂的数据类型都是放在堆中
|      | --> // C语言中堆内存空间的申请和释放需要手动通过代码来完成。对于一个32位操作系统，最大管理管理4G内存，其中1G是给操作系统自己用的，剩下的3G都是给用户程序，一个用户程序理论上可以使用3G的内存空间
|  ↑   | --> // 堆上的内存必须手动释放（C/C++），除非语言执行环境支持GC (垃圾回收)。那堆内存如何使用？请看这章
|  ↑   | --> // 从下往上存储
|  ↑   |
|      |
|------|
|static|
| area | --> // 静态区存放程序中所有的全局变量和静态变量
|------|
| code | --> // 程序被操作系统加载到内存的时候，所有的可执行代码 (程序代码指令、常量字符串等)都加载到代码区
| area | --> // 这块内存在程序运行期间是不变的。代码区是平行的，里面装的就是一堆指令，在程序运行期间是不能改变的
|------| --> // 函数也是代码的一部分，故函数都被放在代码区，包括main函数
   ···
|------| --> 9999 // 高位，尽是示例
```

- 开始讲解之前请看一个实例查看内存地址

```c
#include <stdio.h>
float f = 1.8;


char func(void){
    char c = 'C';
    printf("func \tvariable c \taddress is %p, \tvalue is %c\n",&c,c);

    static unsigned d = 3;
    d++;
    printf("static \tvariable d \taddress is %p, \tvalue is %u\n",&d,d);

    printf("glocal \tvariable f \taddress is %p, \tvalue is %f\n",&f,f);

    return c;
}


int main(int argc, char const *argv[]){
    int n = 10;
    printf("local \tvariable n \taddress is %p, \tvalue is %i\n",&n,n);

    char m = func();
    printf("local \tvariable m \taddress is %p, \tvalue is %c\n",&m,m);

    func();

    printf("glocal \tvariable f \taddress is %p, \tvalue is %f\n",&f,f);

    return 0;
}

// 可以看出不同变量的地址存放
```

> 栈不会很大，一般都是以 K 为单位。如果在程序中直接将较大的数组保存在函数内的栈变量中，很可能会**内存溢出，导致程序崩溃**

```c
#include <stdio.h>


int main(void){
    char array_char[1024*1024*1024] = {0};
    array_char[0] = 'a';
    printf("%s", array_char);

    return 0;
}

// 可以编译但无法运行
```

#### 2.malloc()函数

- **_malloc()函数用于分配内存，该函数向系统要求一段内存，系统就在 "堆" 里面分配一段连续的内存块给它_**，它的原型定义在**头文件 stdlib.h**

```c
#include <stdlib.h>

void* malloc(size_t size)
```

- 它接受一个**非负整数 (size_t)作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块**。这是非常合理的，因为 malloc()函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针

```c
int* p = (int*)malloc(sizeof(int));

*p = 12;
printf("%d\n", *p); // 12

// 示例请求了四个字节用来存储一个int类型，然后void指针转换为用整数指针存入了12，不能直接存储因为void指针不能用来取值赋值
```

> 由于**sizeof()的参数可以是变量**，所以上面的例子也可以写成下面这样。

```c
int* p = (int*) malloc(sizeof(*p));
```

- **_malloc()分配内存有可能分配失败，这时返回常量 NULL_**。Null 的值为 0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括 stdlib.h 等多个头文件里面都有定义，所以只要可以使用 malloc()，就可以使用 NULL。由于存在分配失败的可能，所以**最好在使用 malloc()之后检查一下，是否分配成功**

```c
int* p = malloc(sizeof(int));

if (p == NULL){
    // 内存分配失败
}
```

> malloc()最常用的场合，就是为数组和自定义数据结构 (之后讲)分配内存

```c
int* p = (int*) malloc(sizeof(int) * 10);

for (int i = 0; i < 10; i++)
  p[i] = i * 5;

// 上面示例中，p是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组
```

- malloc()用来创建数组，有一个好处，就是**它可以创建动态数组**，即根据成员数量的不同，而创建长度不同的数组

```c
int* p = (int*) malloc(n * sizeof(int));

// malloc()可以根据变量n的不同，动态为数组分配不同的大小。
```

> 注意，malloc()不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用 strcpy()函数。

```c
char* p = malloc(4);
strcpy(p, "abc");

// 字符指针p指向一段4个字节的内存，strcpy()将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化
```

#### 3.free()函数

- **_free()用于释放 malloc()函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束_**。该函数的原型定义在**头文件 stdlib.h**里面

```c
void free(void* block)
```

```c
int* p = (int*) malloc(sizeof(int));

*p = 12;
printf("%d\n", *p);

free(p);
// 释放
```

- **_注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用 free()对该地址释放第二次_**

```c
// 一个常见的错误

#include <stdio.h>

void func(void){
    int *p = (int*) malloc(sizeof(int));
}


int main(void){
    func();
    func();

    return 0;
}

// 这里函数内没有释放malloc申请的内存，导致在堆内的数据一直存在
// 而且调用了多次，会一直累计
// 而且也没法通过函数返回值的方式释放指针，因为指针是在栈内的
```

> 这种 malloc 申请的内存一直存在指向它的指针却不存在的情况就叫**内存泄漏 (Memory Leak)**，直到程序运行结束由操作系统回收

#### 4.calloc()函数

- **calloc()函数的作用与 malloc()相似，也是分配内存块。该函数的原型定义在头文件 stdlib.h**，两者的区别主要有两点：

1. **_calloc()接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度_**

```c
void* calloc(size_t n, size_t size);
```

> calloc()的**返回值也是一个 void 指针。分配失败时，返回 NULL**

2. **_calloc()会将所分配的内存全部初始化为 0_**。malloc()不会对内存进行初始化，如果想要初始化为 0，还要额外调用 memset()函数。

```c
int* p = calloc(10, sizeof(int));

// 等同于
int* p = malloc(sizeof(int) * 10);
memset(p, 0, sizeof(int) * 10);
```

- **calloc()分配的内存块，也要使用 free()释放**

#### 5. realloc()函数

- **_realloc()函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针_**。如果**分配不成功，返回 NULL**。该函数的**原型定义在头文件 stdlib.h**

```c
void* realloc(void* block, size_t size)
```

- 它**接受两个参数**:

1. block：**已经分配好的内存块指针** (由 malloc()或 calloc()或 realloc()产生)
2. size：**该内存块的新大小，单位为字节**

- realloc()**_可能返回一个全新的地址 (数据也会自动复制过去)，也可能返回跟原来一样的地址_**。realloc()优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果**新内存块小于原来的大小，则丢弃超出的部分**，**如果大于原来的大小，则不对新增的部分进行初始化** (程序员可以自动调用 memset())

```c
// 下面是一个例子，b是数组指针，realloc()动态调整它的大小。

int* b;

b = malloc(sizeof(int) * 10);
b = realloc(b, sizeof(int) * 2000);

// 指针b原来指向10个成员的整数数组，使用realloc()调整为2000个成员的数组。这就是手动分配数组内存的好处，可以在运行时随时调整数组的长度。
```

- **_realloc()的第一个参数可以是 NULL，这时就相当于新建一个指针_**

```c
char* p = realloc(NULL, 3490);

// 等同于

char* p = malloc(3490);
```

- **_如果 realloc()的第二个参数是 0，就会释放掉内存块_**
- 由于有分配失败的可能，所以调用 realloc()以后，**最好检查一下它的返回值是否为 NULL**。分配失败时，原有内存块中的数据不会发生改变

```c
float* new_p = realloc(p, sizeof(*p * 40));

if (new_p == NULL) {
    printf("Error reallocing\n");
    return 1;
}
```

- 注意，**realloc()不会对内存块进行初始化**

#### 6.restrict 说明符

- **_声明指针变量时，可以使用 restrict 说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为 "受限指针" (restrict pointer)_**

```c
int* restrict p;
p = malloc(sizeof(int));

int* q = p;
*q = 0; // 未定义行为
```

> p 是一个受限指针，另一个指针 q 与 p 指向同一块内存，现在该内存有 p 和 q 两种访问方式。这就违反了对编译器的承诺，后面通过\*q 对该内存区域赋值，会导致未定义行为

#### 7.memcpy()函数

- **_memcpy()用于将一块内存拷贝到另一块内存。该函数的原型定义在头文件 string.h_**

```c
void* memcpy(
    void* restrict dest,
    void* restrict source,
    size_t n
);
```

- **dest 是目标地址，source 是源地址，第三个参数 n 是要拷贝的字节数 n**。如果要拷贝 10 个 double 类型的数组成员，n 就等于 10 \* sizeof(double)，而不是 10。该函数会将从 source 开始的 n 个字节，拷贝到 dest
- **dest 和 source 都是 void 指针，表示这里不限制指针类型**，各种类型的内存数据都可以拷贝。两者都有 restrict 关键字，表示**这两个内存块不应该有互相重叠的区域**
- **_memcpy()的返回值是第一个参数，即目标地址的指针_**
  > 因为 memcpy()只是将一段内存的值，复制到另一段内存，所以**不需要知道内存里面的数据是什么类型**

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char s[] = "Goats!";
    char t[100];

    memcpy(t, s, sizeof(s));  // 拷贝7个字节，包括终止符

    printf("%s\n", t);  // "Goats!"

    return 0;
}

// 字符串s所在的内存，被拷贝到字符数组t所在的内存
```

- memcpy()可以取代 strcpy()进行字符串拷贝，而且是更好的方法，不仅更安全，速度也更快，**它不检查字符串尾部的\0 字符**

```c
char* s = "hello world";

size_t len = strlen(s) + 1;
char *c = malloc(len);

if (c){
    // strcpy() 的写法
    strcpy(c, s);

    // memcpy() 的写法
    memcpy(c, s, len);
}

// 两种写法的效果完全一样，但是memcpy()的写法要好于strcpy()
```

- **使用 void 指针，也可以自定义一个复制内存的函数**

```c
void* my_memcpy(void* dest, void* src, int byte_count) {
    char* s = src;
    char* d = dest;

    while (byte_count--) {
        *d++ = *s++;
    }

    return dest;

}

// 不管传入的dest和src是什么类型的指针，将它们重新定义成一字节的 Char 指针，这样就可以逐字节进行复制
// *d++ = *s++语句相当于先执行*d = *s (源字节的值复制给目标字节)，然后各自移动到下一个字节。最后，返回复制后的dest指针，便于后续使用

```

#### 8.memmove()函数

- **memmove()函数用于将一段内存数据复制到另一段内存**。它跟 memcpy()的主要区别是，**_它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改_**，如果没有重叠，它与 memcpy()行为相同
  > 该函数的原型定义在头文件**string.h**

```c
void* memmove(
    void* dest,
    void* source,
    size_t n
);

// dest是目标地址，source是源地址，n是要移动的字节数。dest和source都是 void 指针，表示可以移动任何类型的内存数据，两个内存区域可以有重叠
```

- memmove()**返回值是第一个参数，即目标地址的指针**

```c
int a[100];
// ...

memmove(&a[0], &a[1], 99 * sizeof(int));

// 从数组成员a[1]开始的99个成员，都向前 (向0方向) 移动一个位置


char x[] = "Home Sweet Home";

printf("%s\n", (char *) memmove(x, &x[5], 10));

// 从字符串x的5号位置开始的10个字节，就是 "Sweet Home" ，memmove()将其前移到0号位置，所以x就变成了 "Sweet Home Home"
```

#### 9.memcmp()函数

- **_memcmp()函数用来比较两个内存区域_**，它的**原型定义在 string.h**

```c
int memcmp(
    const void* s1,
    const void* s2,
    size_t n
);
```

- 它接受三个参数，**_前两个参数是用来比较的指针，第三个参数指定比较的字节数_**
- 它的**返回值是一个整数**，两块内存区域的**每个字节以字符形式解读**，按照字典顺序进行比较，如果**两者相同，返回 0**；如果**s1 大于 s2，返回大于 0 的整数**；如果**s1 小于 s2，返回小于 0 的整数**

```c
char* s1 = "abc";
char* s2 = "acd";
int r = memcmp(s1, s2, 3); // 小于 0

// 比较s1和s2的前三个字节，由于s1小于s2，所以r是一个小于0的整数，一般为-1
// 当然跟上面的strcmp一样，取决于你的编译器也可以输出别的


char s1[] = {'b', 'i', 'g', '\0', 'c', 'a', 'r'};
char s2[] = {'b', 'i', 'g', '\0', 'c', 'a', 't'};

if (memcmp(s1, s2, 3) == 0) // true
if (memcmp(s1, s2, 4) == 0) // true
if (memcmp(s1, s2, 7) == 0) // false

// memcmp()也可以比较字符串终止符\0
```

### 拾伍：struct 结构体

#### 1.概念

> 通过之前的讲解可以看出 C 语言并没有提供很多符合类型或者高级结构，只有数组一个，但是还只能存储单一结构实际意义不大，但是 C 也提供了一个结构体用于自定义结构

> 同时 C 语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能

- **_结构体定义使用 struct 关键字_**：

```c
struct number{
    int positive;
    int value;
};

// 注意必须带struct编译器才知道这是结构体，不带或者名字后面不加花括号不算
```

- 定义了新的数据类型以后，就可以**_声明该类型的变量，这与声明其他类型变量的写法是一样的_**

```c
struct number n1;

n1.positive = 1;
n1.value = 34;

// 先声明了一个struct number类型的变量n1，这时编译器就会为n1分配内存，接着就可以为n1的不同属性赋值。可以看到，struct 结构的属性通过点 . 来表示，比如numerator属性要写成n1.value
// 声明自定义类型的变量时，类型名前面，不要忘记加上struct关键字。也就是说，必须使用struct number n1声明变量，不能写成fraction n1
```

> 除了逐一对属性赋值，也可以**使用大括号，一次性对 struct 结构的所有属性赋值**

```c
struct number n1 = {1,34};

// 果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为0

// 注意，大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名

struct number n1 = {.positive = 1,.value = 34};
```

- **_声明变量以后，也可以再次修改某个属性的值_**

```c
n1.value = 90;
```

- struct 的**_数据类型声明语句与变量的声明语句，可以合并为一个语句_**

```c
struct number{
    int positive;
    int value;
} n1;

// 上面的语句同时声明了数据类型number和该类型的变量n1，如果类型标识符number只用在这一个地方，后面不再用到，这里可以将类型名省略
```

> **_struct 也可以声明匿名数据类型_**，单次使用很方便

```c
struct {
    int positive;
    int value;
} n1;
```

- 与其他变量声明语句一样，**_可以在声明变量的同时，对变量赋值_**

```c
struct number{
    int positive;
    int value;
} n1 = {.positive = 0,.value = 20},
  n2 = {.positive = 1,.value = 64};

// 在声明n1，n2的同时为二者赋值
```

- **_指针变量也可以指向 struct 结构_**

```c
struct number{
    int positive;
    int value;
} * n1;

// 也可以写成

struct number{
    int positive;
    int value;
};

struct number* n2;
```

- **_数组的成员也可以是 struct 定义的结构_**

```c
struct number numbers[100];

numbers[0].positive = 1;
numbers[0].value = 985;
numbers[34].value = 30;

// 声明一个number结构的numbers数组，里面每一个元素都拥有number结构的属性，再给第一个元素的positive和value赋值
```

- struct 结构占用的存储空间，不是各个属性存储空间的总和，而是**_最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐_**。这样可以**提高读写效率**

```c
struct mytype {
    int a;
    char* b;
    char c;
};

printf("%d\n", sizeof(struct mytype));

>>> 24

// struct mytype有三个属性，在64位计算机上占用的存储空间分别是：int a占4个字节，指针char* b占8个字节，char c占1个字节
// 它们加起来，一共是13个字节（4 + 8 + 1）
// 但是实际上，struct mytype会占用24个字节，原因是它最大的内存占用属性是char* b的8个字节，导致其他属性的存储空间也是8个字节，这样才可以对齐，导致整个struct foo就是24个字节（8 * 3）
```

> **_多出来的存储空间，都采用空位填充_**，所以上面的 struct 真实的结构其实是下面这样

```c
struct mytype {
    int a;        // 4
    char pad1[4]; // 填充4字节
    char *b;      // 8
    char c;       // 1
    char pad2[7]; // 填充7字节
};

printf("%d\n", sizeof(struct foo)); // 24
```

> 为什么浪费这么多空间进行内存对齐呢？这是为了**_加快读写速度_**，把内存占用划分成等长的区块，就可以**_快速在 Struct 结构体中定位到每个属性的起始地址_**

- 结构体对齐规则：

  - 一：结构体对齐规则首先要看有没有**用#pragma pack 宏声明，这个宏可以改变对齐规则**，有宏定义的情况下结构体的自身宽度就是宏上规定的数值大小，所有内存都按照这个宽度去布局（这样说其实不太严谨，后面会提到），#**pragma pack 参数只能是 '1', '2', '4', '8', or '16'**

  - 二：在没有#pragma pack 这个宏的声明下，遵循下面**三个原则**：

1. **_第一个成员的首地址 (偏移量更准确)为 0_**
2. **_每个成员的首地址是自身大小的整数倍_**
3. **_结构体的总大小，为其成员中所含最大类型的整数倍_**

```c
struct test {
    char a;  //1
    char b;  //1
    char c;  //1
};

// 这个没问题

struct test {
    char a; //1
    short b; //2
    char c; //1
};

// 因为short占两字节根据第二法则它只能放在0,2,4这种地方，所以char a之后的一位被浪费，最后的char c之后的一位因为第三法则也得浪费，所以是2 * 3 等于6位

struct test {
    char a;   //1+3
    int  b;    //4
    short c;    //2+2
};

struct test {
    char c; //1+3
    int a; //4
    char* b; // 8
};

// 不能简单地理解为3*8=24
// 所以只需要16字节就够了
```

> 由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以**_采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间_**

```c
// 那如果加上pragma

#pragma  pack(1)

struct test {
    char a;
    int  b;
};

// 这就不需要补位了，大小是5

#pragma  pack(8)

struct test {
    char a;
    int  b;
    short c;
};

// 按照分析，使用宏强制8字节对齐之后，最后的c应该是占8字节，一共是16个字节，但是结果是12，也就是说编译器没有听你的，它认为最大的数据类型长度是4，所以按4就行了，而不必按8
```

> **_严格来说，是按照这个宏声明的和实际数据类型中最大值较小的那个来决定_**

#### 2.复制

- **_struct 变量可以使用赋值运算符 = ，复制给另一个变量，这时会生成一个全新的副本_**。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即**原样生成了一份数据，这一点跟数组的复制不一样**
  > 这种赋值**要求两个变量是同一个类型**，不同类型的 struct 变量无法互相赋值

```c
struct str {
    int positive;
    char name[10];
} a,b;

strcpy(a.name,"peter");
a.positive = 0;

b = a;
b.name[0] = 'T';

printf("a is %s\nb is %s\n",a.name,b.name);

// 这一点与数组不同，可以理解为这是深拷贝
```

- 示例是有前提的，就是 **struct 结构的属性必须定义成字符数组，才能复制数据**。如果稍作修改，属性定义成字符指针，结果就不一样

```c
struct cat { char* name; short age; } a, b;

a.name = "Hula";
a.age = 3;

b = a;

// name属性变成了一个字符指针，这时a赋值给b，导致b.name也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址
// struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针
// 并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的
```

> 另外，**C 语言没有提供比较两个自定义数据结构是否相等的方法**，无法用比较运算符 (比如==和!=) 比较两个数据结构是否相等或不等，要自己造轮子

#### 3.struct 指针

- 如果将 struct 变量传入函数，同样**_函数内部得到的是一个 struct 原始值的副本_**

```c
#include <stdio.h>

struct turtle {
    char* name;
    char* species;
    int age;
};

void happy(struct turtle t) {
    t.age = t.age + 1;
}

int main() {
    struct turtle myTurtle = {"MyTurtle", "sea turtle", 99};
    happy(myTurtle);
    printf("Age is %i\n", myTurtle.age); // 输出 99
    return 0;
}
```

- 如果需要改变外部结构，就需要将 **_struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部_**
  > **struct 指针传入函数的写法**如下：

```c
void happy(struct turtle* t) {
}

happy(&myTurtle);
```

> **t 是 struct 结构的指针，调用函数时传入的是指针**。struct 类型跟数组不一样，**类型标识符本身并不是指针**，所以传入时，指针必须写成&myTurtle

- **函数内部也必须使用(\*t).age 的写法**，从指针拿到 struct 结构本身

```c
void happy(struct turtle* t) {
    (*t).age = (*t).age + 1;
}

// (*t).age不能写成*t.age，因为点运算符.的优先级高于*。*t.age这种写法会将t.age看成一个指针，然后取它对应的值，会出现无法预料的结果
```

- (\*t).age 这样的写法很麻烦。C 语言就引入了一个**_新的箭头运算符 -> ，可以从 struct 指针上直接获取属性_**，大大增强了代码的可读性

```c
void happy(struct turtle* t) {
    t->age = t->age + 1;
}

// 对于 struct 变量名，使用点运算符 . 获取属性；对于 struct 变量指针，使用箭头运算符 -> 获取属性

// 以变量myStruct为例，假设ptr是它的指针，那么下面三种写法是同一回事

// ptr == &myStruct
myStruct.prop == (*ptr).prop == ptr->prop
```

#### 4.struct 的嵌套

- **_struct 结构的成员可以是另一个 struct 结构_**

```c
struct brand {
    char brand_name;
    int series;
};

struct mirrorless {
    int weight;
    long int pixels;
    struct brand Japen_brand;
};
```

- **_赋值的时候有多种写法_**

```c
// 写法一
struct mirrorless Z5 = {675,2432,{"Nikon",'Z'}};

// 写法二
struct brand nikkor = {"Nikon",'Z'};
struct mirrorless Z5 = {675,2432,nikkor};

// 写法三
struct mirrorless Z5 = {
    .weight = 675,
    .pixels = 2432,
    .Japen_brand = {"Nikon",'Z'}
};

// 写法四
struct mirrorless Z5 = {
    .weight = 675,
    .pixels = 2432,
    .Japen_brand.brand_name = "Nikon",
    .Japen_brand.series = 'Z'
    // 运用两次点运算符
};
```

> 下面是另一个嵌套 struct 的例子

```c
struct name {
    char first[50];
    char last[50];
};

struct student {
    struct name name;
    short age;
    char sex;
} student1;

strcpy(student1.name.first, "Harry");
strcpy(student1.name.last, "Potter");

// or
struct name myname = {"Harry", "Potter"};
student1.name = myname;

// 自定义类型student的name属性是另一个自定义类型，如果要引用后者的属性，就必须使用两个.运算符，比如student1.name.first
// 另外，对字符数组属性赋值，要使用strcpy()函数，不能直接赋值，因为直接改掉字符数组名的地址会报错
```

- struct 结构内部不仅可以引用其他结构，**_还可以自我引用，即结构内部引用当前结构_**。比如，链表结构的节点就可以写成下面这样

```c
// 还记得链表吧，可以看数据结构那章

struct node {
    int data;
    struct node* next;
};

// node结构的next属性，就是指向另一个node实例的指针。下面，使用这个结构自定义一个数据链表
```

```c
// 生成一个三个节点的列表 (11)->(22)->(33)

struct node {
    int data;
    struct node* next;
};

struct node* head;
// 这里只是声明了一个指针，指向一个数据体结构，但是具体指向谁还没有说

head = (node *)malloc(sizeof(struct node));
// 现在指向了堆中4+4+8(不确定)字节的空间，这个空间格式为node结构
// malloc返回一个指针赋值给head
// 还可以注意一下sizeof(struct node)不能是sizeof(node)，也可以是sizeof(head)，但是现在还没有分配

head->data = 11; // (*head).data = 11，头文件第一个数据为11
head->next = malloc(sizeof(struct node)); // 再指向一块新空间

head->next->data = 22;
head->next->next = malloc(sizeof(struct node));

head->next->next->data = 33;
head->next->next->next = NULL;
// 重复一遍，最后尾指针定义为NULL

// 遍历这个列表
for (struct node *cur = head; cur != NULL; cur = cur->next) {
    // 这里请注意，Head是一个指向堆空间中一个struct结构体的指针
    // 又声明一个局部变量cur也是一个指向struct的结构体的指针，但是将head的值，也就是堆空间中那个结构体链表的地址赋给cur，会直接让cur也指向那个空间，而不是指向head这个指针
    // cur != NULL，不是说他自己知道下一个是谁，能去分析next里面是不是NULL，而是它本身是谁，运行到head->next->next->next = NULL;这里时cur本身已经全是NULL了，并没有分配struct空间
    // cur = cur->next是指它的值变成指向下一个next的指针

    printf("%d\n", cur->data);
}
```

#### 5.位字段

- **_struct 还可以用来定义二进制位组成的数据结构，称为 "位字段" (bit field)_**，这对于操作底层的二进制数据非常有用

```c
struct {
  unsigned int ab:1;
  unsigned int cd:1;
  unsigned int ef:1;
  unsigned int gh:1;
} synth;

synth.ab = 0;
synth.cd = 1;

// 每个属性后面的:1，表示指定这些属性只占用一个二进制位 (也就是只能存储0或1)，所以这个数据结构一共是4个二进制位。
```

- 注意，定义二进制位时，**_结构内部的各个属性只能是整数类型_**
- 实际存储的时候，**_C 语言会按照 int 类型占用的字节数，存储一个位字段结构 (也就是 4 字节)_**。如果有剩余的二进制位，可以使用**未命名属性，填满那些位**。也可以使用**宽度为 0 的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节**

```c
struct {
    unsigned int field1 : 1;
    unsigned int        : 2;
    unsigned int field2 : 1;
    unsigned int        : 0;
    unsigned int field3 : 1;
} stuff;

// stuff.field1与stuff.field2之间，有一个宽度为两个二进制位的未命名属性占用
// 因为有一个宽度为0的匿名属性，stuff.field3将存储在下一个字节
```

#### 6.弹性数组成员

- 很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做**_弹性数组成员 (flexible array member)_**
- 如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。

```c
struct vstring {
    int len;
    char chars[];
};

// struct vstring结构有两个属性。len属性用来记录数组chars的长度，chars属性是一个数组，但是没有给出成员数量
```

> chars 数组到底有多少个成员，可以在为 vstring 分配内存时确定

```c
struct vstring {
    int len;
    char chars[];
};

char* c = "asdf";

struct vstring* str = malloc(sizeof(struct vstring) + strlen(c) + 1);
// +1 为了 \0

str->len = n;

// 假定chars数组的成员数量是n，只有在运行时才能知道n到底是多少。然后，就为struct vstring分配它需要的内存：它本身占用的内存长度，再加上n个数组成员占用的内存长度。最后，len属性记录一下n是多少
```

> 这样就可以让数组 chars 有 n 个成员，不用事先确定，可以跟运行时的需要保持一致

- 弹性数组成员有一些专门的规则。首先，**_弹性成员的数组，必须是 struct 结构的最后一个属性_**。另外，除了弹性数组成员，**_struct 结构必须至少还有一个其他属性_**

#### 7.typedef 命令

##### 7.1 概念

- **_typedef 命令用来为某个类型起别名_**

```c
typedef type name;

// 上面代码中，type代表类型名，name代表别名

typedef unsigned char BYTE;

BYTE c = 'z';

// 等于

unsigned char c = 'Z';
```

> 还可以**增强代码可读性**

```c
typedef char* STRING;

STRING str = "Hello!";

// 这样就知道类型名称
```

- **_typedef 可以一次指定多个别名_**

```c
typedef int antelope, bagel, mushroom;

// 一次性为int类型起了三个别名，使用时都相当于int
```

##### 7.2 给类型起别名

- **_typedef 也可以为指针起别名_**

```c
typedef int* intptr;

int a = 10;
intptr x = &a;

// 这样不容易看出来，变量x是一个指针类型
```

- **_typedef 也可以用来为数组类型起别名_**

```c
typedef int five_ints[5];

five_ints x = {11, 22, 33, 44, 55};

// 等于

int x[5] = {11, 22, 33, 44, 55};
```

- **_typedef 也可以给 struct 结构起别名，语法如下_**

```c
typedef struct myStruct {
    int n;
    int m;
} myStru;

// 其实就是两部分组合到了一块

struct myStruct {
    int n;
    int m;
};
// 这是声明一个结构体

typedef struct myStruct myStru;
// 这是重命名

// 这种情况下，C 语言允许省略 struct 命令后面的类型名，直接写自定义类型名称

typedef struct {
    int n;
    int m;
} myStru;
```

- **_typedef 也可以给函数起别名 (应该是给一个指向函数的指针起别名)_**

```c
int add(int a,int b){
    return a+ b;
};

typedef int (*p_of_add)(int,int);

// 定义p_of_add是一个函数指针, 函数类型是带两个int 参数, 返回一个int

p_of_add = add;
p_of_add(a,b);

// 然后直接使用即可
```

##### 7.3 方便更改变量类型

- typedef **方便以后为变量改类型**

```c
typedef float app_float;

app_float f1, f2, f3;

// 变量f1、f2、f3的类型都是float。如果以后需要为它们改类型，只需要修改typedef语句即可

typedef long double app_float;
```

> 更多的用途是为复杂类型起一个简单明了的名字，比如以下的

```c
char (*(*x(void))[5])(void);

// 你先暂停，看看能不能看懂

typedef char (*Func)(void);
typedef Func Arr[5];
Arr* x(void);

// x是一个函数，返回一个指向 Arr 类型的指针
// Arr是一个数组，有5个成员，每个成员是Func类型
// Func是一个函数指针，指向一个无参数、返回字符值的函数

// 可是我还是看不懂，就跟底下这个一样

char *(*(*a)(void))[20];

// C语言类型声明是从外到里解方程，把右边看做是表达式
// char *(*(*a)(void))[20]中*(*(*a)(void))[20]是一个char
// 所以(*(*a)(void))[20]是一个char*
// 所以*(*a)(void)是一个char*的数组，有20个元素
// 所以(*a)(void)是一个指向20个char*的数组的指针
// 所以*a是无参数并返回指向20个char*的数组的指针的函数
// 所以a是无参数并返回指向20个char*的数组的指针的函数的指针
```

> 多说一嘴，之前讲的可移植类型就是通过 typedef 定义的，可以返回去看

### 拾陆：union 联合体

> 有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示水果的 "量" ，这种结构就需要有时是整数 (6 个苹果)，有时是浮点数 (1.5 公斤草莓)

#### 1.概念

- C 语言提供了 **_Union 结构，用来自定义可以灵活变更的数据结构_**。它内部包含各种属性，但是**_所有属性共用一块内存_**，导致这些属性都是对同一个二进制数据的解读，其中往往只有一个属性的解读是有意义的。并且，**_后面写入的属性会覆盖前面的属性_**，这意味着同一块内存，可以先供某一个属性使用，然后再供另一个属性使用。这样做的最大好处是**节省内存空间**

```c
union quantity {
    short count;
    float weight;
    double volume;
};

// 虽然包含三个属性，但是只能写入一个值，三个属性都是对这个值的不同解读
// 最后赋值的属性，往往就是可以取到有意义的值的那个属性
```

- 下面是三种 union 结构变量的声明写法

```c
// 写法一
union quantity q;
q.count = 4;

// 写法二
union quantity q = {.count=4};

// 写法三
union quantity q = {4};

// 最后一种写法不指定属性名，就会赋值给第一个属性
```

> **只能对赋值过的属性取值**，没有赋值过的取不到值

```c
q.count = 4;

printf("q.count is %d\n",q.count);
printf("q.weight is %f\n",q.weight);
printf("q.volume is %f\n",q.volume);

// 下面两个也有输出，是什么我们接着看
```

#### 2.占用

- 在 union 中，**_分配内存空间的大小，等于占内存最大的数据类型字节大小_**

```c
printf("sizeof union q is %zd byte",sizeof(q));
>>> 8

// 因为double是8字节
```

```c
printf("sizeof union q is %zd byte\n",sizeof(q));
printf("q.count is % zd\n",sizeof(q.count));
printf("q.weight is %zd\n",sizeof(q.weight));
printf("q.volume is %zd\n",sizeof(q.volume));

// 他这里显示是每个类型对应的存储空间

printf("address of q is %p\n",&q);
printf("q.count is %p\n",&q.count);
printf("q.weight is %p\n",&q.weight);
printf("q.volume is %p\n",&q.volume);

// 打印地址都是一样的
```

> 请看下面的 _rbg_ 三原色例子明白**union 结构中的属性共享一个空间**

```c
typedef struct {
    unsigned char Red;
    unsigned char Green;
    unsigned char Blue;
} RGB;

union {
    RGB rgb;
    unsigned int value;
} PIXEL;

// 这里我写的绕了点就是搞清楚typedef与struct或者union共同出现时的分辨，第一段那个typedef可以不写，第二段的union直接声明了 (如果加上typedef就要在声明一次，就像union里面那个rgb一样)

PIXEL.rgb.Red = 45;
PIXEL.rgb.Green = 124;
PIXEL.rgb.Blue = 61;

printf("red is %i\n",PIXEL.rgb.Red);
printf("green is %i\n",PIXEL.rgb.Green);
printf("blue is %i\n",PIXEL.rgb.Blue);

// 这三个毫无悬念，但是下面这个会输出什么？

printf("pixel value is %i\n",PIXEL.value);
>>> 4029485

// 首先打开计算器自带的程序员模式 (Windows上面自带的就挺好)，输入4029485，你应该能看到再二进制模式下是：

0011 1101 0111 1100 0010 1101

// 这是union联合体pixel里存储的数据，因为struct结构rgb占三个字节 (三个char)，但是一个int四字节，所以大的为准占四字节
// 又因为rgb只占三字节，所以4029485占了32位，前面4位浪费掉
// 再关注这三个字节，按照一个字节占八位分开是：

0011 1101
0111 1100
0010 1101

// 正好就是：

61
124
45
```

- **一旦为其他属性赋值，先前的属性便取不到有意义的值**

```c
q.volume = 1.5896543;

printf("q.count is %d\n",q.count);
printf("q.weight is %f\n",q.weight);
printf("q.volume is %f\n",q.volume);
```

- Union 结构指针与它的属性有关，**_当前正在按照哪个属性解读数据，它的指针就是对应的数据类型_**

```c
union foo {
    int a;
    float b;
} x;

int* foo_int_p = (int *)&x;
float* foo_float_p = (float *)&x;

x.a = 12;
printf("%d\n", x.a);           // 12
printf("%d\n", *foo_int_p);    // 12

x.b = 3.141592;
printf("%f\n", x.b);           // 3.141592
printf("%f\n", *foo_float_p);  // 3.141592
```

- **_Union 结构也支持指针运算符 ->_**

```c
union quantity {
    short count;
    float weight;
    float volume;
};

union quantity q;
q.count = 4;

union quantity* ptr;
ptr = &q;

printf("%d\n", ptr->count); // 4

// ptr是q的指针，那么ptr->count等同于q.count
```

### 拾柒：enum 枚举

#### 1.概念

> 举一个例子，我想要定义一个星期的全局常量，如果看过后面的 define 就知道可以一个一个定义

```c
#define MON 1
#define TUE 2
#define WED 3
#define THU 4
#define FRI 5
#define SAT 6
#define SUN 7
```

> 其实还有别的方法

- enum 是 C 语言中的一个关键字，**_enum 叫枚举数据类型，枚举数据类型描述的是一组整型值的集合_**，也就是**一种数据类型的取值只有少数几种可能**，并且**每种取值都有自己的含义而且互有关联**，我们就可以把它定义成一个枚举结构而不是一个一个去手动定义
- 语法如下：

```c
enum typeName { valueName1, valueName2, valueName3, ...... };

// typeName是枚举类型的名字，花括号里面的元素 (枚举成员) 是常量而不是变量，这个一定要搞清楚，因为枚举成员的是常量，所以不能对它们赋值，只能将它们的值赋给其他的变量

enum DAY { MON, TUE, WED, THU, FRI, SAT, SUN };

// 这样就简洁多了
```

> 需要注意:

1. 枚举列表中的 Mon、Tues、Wed **这些标识符的作用范围与变量相同**。如果是在**顶层声明，那么在整个文件内都有效**；如果是在**代码块内部声明，则只对该代码块有效**。如果与使用 int 声明的常量相比，Enum 的好处是更清晰地表示代码意图 ，**不能再定义与它们名字相同的变量**，标识符名一般**均为大写**
2. Mon、Tues、Wed 等**都是常量，不能对它们再赋值**，只能将它们的值赋给其他的变量

- **_枚举类型字都是以整数常量方式存储的_**，编译器默认将它们的值设为数字 0、1、2

```c
printf("%i\n",MON);
printf("%i\n",TUE);
printf("%i\n",WED);

// 0,1,2
```

#### 2.声明与使用

- **声明时**有以下几种方法

```c
// 1.先定义枚举类型，再定义枚举变量
enum DAY {
MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;

// 2.定义枚举类型的同时定义枚举变量
enum DAY {
MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;

// 3.省略枚举名称，直接定义枚举变量
enum {
MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;

// 注意：同一个程序中不能定义同名的枚举类型，不同的枚举类型中也不能存在同名的命名常量
```

> 常量之间使用逗号分隔。**最后一个常量后面的尾逗号，可以省略，也可以保留**

```c
enum { ONE, TWO, };
```

- **使用时要先将变量定义为 enum 类型**

```c
enum DAY today;

// 这个将变量today定义为day类型，today他的值就是day里面的一个值
```

- **可以在声明时就进行赋值，也可以之后再赋值**

```c
enum DAY today;
today = MON;

// 或者

enum DAY yesterday = SUN;

// 无论如何，enum类型也是一个强类型，不能直接拿来用，必须赋值给enum类型的变量
// 对于多个变量也是如此

enum DAY today,yesterday,tomorrow;
today = TUE;
···

enum DAY today = TUE,yesterday = MON,tomorrow = WED;
```

- typedef 也可以给枚举类型起别名

```c
typedef enum /*可省略*/{
  SHEEP,
  WHEAT,
  WOOD,
  BRICK,
  ORE
} RESOURCE;

// 这也是省略enum后面的标识符名称，是允许的

RESOURCE r;

// RESOURCE是 Enum 类型的别名。声明变量时，使用这个别名即可。
```

- 还有一种不常见的写法，就是**声明 Enum 类型时，在同一行里面为变量赋值**

```c
enum {
  SHEEP,
  WHEAT,
  WOOD,
  BRICK,
  ORE
} r = BRICK, s = WOOD;
```

#### 3.赋值

- 由于**Enum 会自动编号**，因此可以不必为常量赋值。**C 语言会自动从 0 开始递增，为常量赋值**。但是，C 语言也允许为 ENUM 常量指定值，不过**只能指定为整数，后面一个常量顺序加一**不能是其他类型。因此，任何可以使用整数的场合，都可以使用 Enum 常量

```c
enum { ONE = 1, TWO = 2 };

printf("%d %d", ONE, TWO);  // 1 2
```

- Enum 常量**可以是不连续的值**

```c
enum { X = 2, Y = 18, Z = -2 };
```

- Enum 常量**也可以是同一个值**

```c
enum { X = 2, Y = 2, Z = 2 };
```

- 如果一组常量之中，有些指定了值，有些没有指定。那么，**_没有指定值的常量会从上一个指定了值的常量，开始自动递增赋值_**

```c
enum {
    A,    // 0
    B,    // 1
    C = 4,  // 4
    D,    // 5
    E,    // 6
    F = 3,   // 3
    G,    // 4
    H     // 5
};
```

> 最后补一嘴，宏和枚举的区别，**宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值**。我们可以将枚举理解为编译阶段的宏

## 第四章：系统与操作

### 拾捌：预处理器 (Preprocessor)

#### 1.概念

- C 语言编译器在编译程序之前，**会先使用预处理器 (preprocessor) 处理代码**
- 预处理器首先会清理代码，进行删除注释、多行语句合成一个逻辑行等工作。然后，**执行 # 开头的预处理指令**。本章介绍 C 语言的预处理指令
- 预处理指令可以出现在程序的任何地方，但是习惯上，**_往往把 # 放在代码的开头部分_**
- **_每个预处理指令都以#开头，放在一行的行首_**，指令前面可以有空白字符（比如空格或制表符）。#和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，**_# 和指令的其余部分之间一般不留空格_**
  > 所以之前的#define 是错误的，请注意，那样写只是方便 markdown 渲染
- 所有**_预处理指令都是一行的_**，除非在行尾使用反斜杠，将其折行。**_指令结尾处不需要分号_**

#### 2.#define

- #define 是最常见的预处理指令，**_用来将指定的词替换成另一个词_**。它的参数分成两个部分，第一个参数就是要被替换的部分，其余参数是替换后的内容。**_每条替换规则，称为一个宏 (macro)_**

```c
#define MAX 100

// 将代码内所有的MAX替换为100，也可以当作常量来使用
// MAX就称为一个宏
```

- **_宏的名称不允许有空格，而且必须遵守 C 语言的变量命名规则_**，只能使用字母、数字与下划线 \_ ，且**_首字符不能是数字_**
- **_宏是原样替换，指定什么内容，就一模一样替换成什么内容_**

```c
#define HELLO "Hello, world"

// 相当于 printf("%s", "Hello, world");
printf("%s", HELLO);
```

> **#define 指令可以出现在源码文件的任何地方** (包括函数内部)，从指令出现的地方到文件末尾都有效。习惯上，会**将#define 放在源码文件的头部**。它的主要好处是，会使得程序的可读性更好，也更容易修改

- **_#define 指令从#开始，一直到换行符为止_**。如果整条指令过长，可以在折行处**使用反斜杠，延续到下一行**

```c
#define OW "C programming language is invented \
in 1970s."

/// 开头不能有空格记得
```

- #define 允许多重替换，即**_一个宏可以包含另一个宏_**

```c
#define TWO 2
#define FOUR TWO*TWO

// FOUR = 2*2
```

> 注意，如果**宏出现在字符串里面 (即出现在双引号中)，或者是其他标识符的一部分，就会失效**，并不会发生替换

```c
#define TWO 2

// 输出 TWO
printf("TWO\n");

// 输出 22
const TWOs = 22;
printf("%d\n", TWOs);
// 他不认为这是TWO而是另一个常量
```

- **_同名的宏可以重复定义，只要定义是相同的，就没有问题_**。如果定义不同，就会报错

```c
// 正确
#define FOO hello
#define FOO hello

// 报错
#define BAR hello
#define BAR world
```

#### 3.带参数的宏

##### 3.1 概念

- 宏的强大之处在于，**_它的名称后面可以使用括号，指定接受一个或多个参数_**，这样就可以在程序运行时动态调整

```c
#define SQUARE(X) X*X

// 宏SQUARE可以接受一个参数X，替换成X*X

a = SQUARE(2);

// a = 2*2
```

> 注意，**_宏的名称与左边圆括号之间，不能有空格_**

- 这种写法很像函数，但又不是函数，**_而是完全原样的替换_**，会跟函数有不一样的行为

```c
#define SQUARE(X) X*X

printf("%d\n", SQUARE(3 + 4));

// 如果是函数，输出应该是7*7=49
// 宏是原样替换，所以替换成3 + 4*3 + 4，最后输出19
```

> 可以看到，原样替换可能导致意料之外的行为。解决办法就是在定义宏的时候，**尽量多使用圆括号**，这样可以避免很多意外

```c
#define SQUARE(X) ((X) * (X))
```

- **_宏的参数也可以是空的_**，这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数

```c
#define getchar() getc(stdin)
```

> **一般来说，带参数的宏都是一行的**

```c
#define MAX(x, y) ((x)>(y)?(x):(y))

// 三元表达式

#define IS_EVEN(n) ((n)%2==0)

// 奇偶判断
```

- 如果宏的长度过长，**_可以使用反斜杠 \ 折行，将宏写成多行_**

```c
// 这是交换两个参数

#define SWAP(x, y){\
x = x + y;\
y = x - y;\
x = x - y;\
}

// 替换文本放在大括号里面，这是为了创造一个块作用域，避免宏内部的变量污染外部
```

- 带参数的宏也可以嵌套，**_一个宏里面包含另一个宏_**

```c
#define QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))
#define QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))
#define QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)

// 上面示例是一元二次方程组求解的宏，由于存在正负两个解，所以宏QUAD先替换成另外两个宏QUADP和QUADM，后者再各自替换成一个解
```

> 那么，什么时候使用带参数的宏，什么时候使用函数呢？

> 一般来说，应该首先使用**函数，它的功能更强、更容易理解**。宏有时候会产生意想不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差

> 宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，**不像函数必须定义数据类型**。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以**性能会好一些**。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解

##### 3.2 # 和 ## 运算符

- 由于宏不涉及数据类型，所以替换以后可能为各种类型的值。**_如果希望替换后的值为字符串，可以在替换文本的参数前面加上#_**

```c
#define STR(x) #x

// 等同于 printf("%s\n", "3.14159");
printf("%s\n", STR(3.14159));

// STR(3.14159)会被替换成3.14159。如果x前面没有#，这会被解释成一个浮点数，有了#以后，就会被转换成字符串
```

> 下面是另一个例子

```c
#define XNAME(n) "x"#n

printf("%s\n", XNAME(4));
// 输出 x4
// 字符串自动链接

// #n指定参数输出为字符串，再跟前面的字符串结合，最终输出为"x4"
```

- 如果替换后的文本里面，**_参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用##运算符_**。它起到粘合作用，将参数 "嵌入" 一个标识符之中
- 一定要注意，**_使用 ## 替换后的文本是标识符_**，可以看作变量名，**##运算符的一个主要用途是批量生成变量名和标识符**

```c
#include <stdio.h>


#define XNAME(n) x##n

// 再说一遍，返回的是一个标识符，所以你不能把它当作一个值，只能当作一个变量名称去声明或者赋值

#define PRINT_XN(n) printf("x"#n"=%d\n",x##n)

// "x"#n"=%d\n" 就是"x数=%d\n"，字符自动连接
// #n会自动从参数取值再变为字符串
// %d从x##n取值，x##n是返回一个变量名，如果这个变量没有被定义就会报错

int main(int argc, char const *argv[]){
    int x1 = XNAME(1);
    int x2 = XNAME(2);
    int x3 = 78;

    // 这也是为什么这里要先声明

    PRINT_XN(1);
    PRINT_XN(2);
    PRINT_XN(3);

    // 你给他传一个123必须是和上面的x123变量名相同，不然读不到
    return 0;
}

// 一定记住，##返回一个标识符
```

> define 就是替换，它本身的作用域就是从定义开始到文件结束，但是在**宏里面的声明语句遵守宏调用时所在作用域规则**

##### 3.3 不定参数的宏

- **_宏的参数还可以是不定数量的 (即不确定有多少个参数)，... 表示剩余的参数_**

```c
#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__

// X(a, b, ...)表示X()至少有两个参数，多余的参数使用...表示。在替换文本中，__VA_ARGS__代表多余的参数 (每个参数之间使用逗号分隔)

X(5, 4, 3.14, "Hi!", 12)
// 替换成
(10*(5) + 20*(4)), 3.14, "Hi!", 12
```

- 注意，**... 只能替代宏的尾部参数**，不能写成下面这样

```c
// 报错
#define WRONG(X, ..., Y) #X #__VA_ARGS__ #Y
```

- **VA_ARGS**前面加上一个#号，可以让输出变成一个字符串

```c
#define X(...) #__VA_ARGS__

printf("%s\n", X(1,2,3));  // Prints "1, 2, 3"
```

#### 4.#undef

- **_#undef 指令用来取消已经使用#define 定义的宏_**

```c
#define LIMIT 400
#undef LIMIT
```

- 有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用#undef 取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，**_而#undef 的参数如果是不存在的宏，并不会报错_**
  > **GCC 的-U 选项可以在命令行取消宏的定义**，相当于#undef

```
$ gcc -ULIMIT foo.c
```

> 上面示例中的-U 参数，取消了宏 LIMIT，相当于源文件里面的#undef LIMIT

#### 5. #include

> 其实一直在用这个，之前多文件编译讲了一下，这里以及后面再复习一下

- **_#include 指令用于编译时将其他源码文件，加载进入当前文件_**。它有两种形式

```c
// 形式一
#include <foo.h> // 加载系统提供的文件

// 形式二
#include "foo.h" // 加载用户提供的文件
```

1. 形式一，**_文件名写在尖括号里面，表示该文件是系统提供的_**，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件
2. 形式二，**_文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置_**，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径，下面是一个例子

```c
#include "/usr/local/lib/foo.h"

// GCC 编译器的-I参数，也可以用来指定include命令中用户文件的加载路径

$ gcc -Iinclude/ -o code code.c

上面命令中，-Iinclude/指定从当前目录的include子目录里面，加载用户自己的文件
```

- #include 最常见的用途，就是用来加载包含函数原型的头文件（后缀名为.h），参见《多文件编译》一章。多个#include 指令的顺序无关紧要，多次包含同一个头文件也是合法的

#### 6.#if···#endif···

- **_#if...#endif 指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略_**

```c
#if 0
    const double pi = 3.1415; // 不会执行
#endif

// #if后面的0，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。#if 0这种写法常用来当作注释使用，不需要的代码就放在#if 0里面
```

- **_#if 后面的判断条件，通常是一个表达式_**。如果表达式的值不等于 0，就表示判断条件为真，编译内部的语句；如果表达式的值等于 0，表示判断条件为伪，则忽略内部的语句
- **_#if...#endif 之间还可以加入#else 指令，用于指定判断条件不成立时，需要编译的语句_**

```c
#define FOO 1

#if FOO
    printf("defined\n");
#else
    printf("not defined\n");
#endif

// 宏FOO如果定义过，会被替换成1，从而输出defined，否则输出not defined
```

> 这里有一个坑，如果你按照上面的运行是不行的，显示 printf 未定义

```c
// 能运行

#include <stdio.h>

#define FOO 1


int main(int argc, char const *argv[]){
    printf("dsa");

    #if FOO
        printf("dsa");
    #endif


    return 0;
}

// 不能运行

#include <stdio.h>

#define FOO 1

#if FOO
    printf("dsa");
#endif

int main(int argc, char const *argv[]){
    printf("dsa");

    return 0;
}

// 应该是include和if同时作为预处理器执行时，if还读不到include里面的，所以注意一下
```

- **_如果有多个判断条件，还可以加入#elif 命令_**

```c
#if HAPPY_FACTOR == 0
    printf("I'm not happy!\n");
#elif HAPPY_FACTOR == 1
    printf("I'm just regular\n");
#else
    printf("I'm extra happy!\n");
#endif

// 通过#elif指定了第二重判断。注意，#elif的位置必须在#else之前。如果多个判断条件皆不满足，则执行#else的部分
```

- **_没有定义过的宏，等同于 0_**。因此如果 UNDEFINED 是一个没有定义过的宏，那么#if UNDEFINED 为伪，而#if !UNDEFINED 为真
- #if 的常见应用就是打开 (或关闭) **调试模式** (之后讲)

```c
#define DEBUG 1

#if DEBUG
    printf("value of i : %d\n", i);
    printf("value of j : %d\n", j);
#endif

// 通过将DEBUG设为1，就打开了调试模式，可以输出调试信息。
```

> **GCC 的-D 参数可以在编译时指定宏的值**，因此可以很方便地打开调试开关。

```c
$ gcc -DDEBUG=1 foo.c

// -D参数指定宏DEBUG为1，相当于在代码中指定#define DEBUG 1。
```

#### 7.#ifdef···#endif···

- **_#ifdef...#endif 指令用于判断某个宏是否定义过_**
  > 有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用#define 定义一个空的宏。通过这个宏，判断库文件是否被加载了

```c
#define EXTRA_HAPPY

// EXTRA_HAPPY就是一个空的宏
```

> 然后，源码文件使用#ifdef...#endif 检查这个宏是否定义过

```c
#ifdef EXTRA_HAPPY
    printf("I'm extra happy!\n");
#endif

// #ifdef检查宏EXTRA_HAPPY是否定义过。如果已经存在，表示加载过库文件，就会打印一行提示
```

- **#ifdef 可以与#else 指令配合使用**

```c
#ifdef EXTRA_HAPPY
    printf("I'm extra happy!\n");
#else
    printf("I'm just regular\n");
#endif

// 如果宏EXTRA_HAPPY没有定义过，就会执行#else的部分。
```

- **#ifdef...#else...#endif 可以用来实现条件加载**

```c
#ifdef MAVIS
    #include "foo.h"
    #define STABLES 1
#else
    #include "bar.h"
    #define STABLES 2
#endif

// 通过判断宏MAVIS是否定义过，实现加载不同的头文件
```

- ifdef 最常用的时候就是用于检查多文件编译时有无重复定义情况

#### 8.defined 运算符

> 上一节的#ifdef 指令，等同于#if defined

```c
#ifdef FOO
// 等同于
#if defined FOO

// 上面示例中，defined是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0
```

- **使用这种语法，可以完成多重判断**

```c
#if defined FOO
    x = 2;
#elif defined BAR
    x = 3;
#endif

// 这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件

#if defined IBMPC
    #include "ibmpc.h"
#elif defined MAC
    #include "mac.h"
#else
    #include "general.h"
#endif

// 不同架构的系统需要定义对应的宏。代码根据不同的宏，加载对应的头文件
```

#### 9.#ifndef...#endif

- **_#ifndef...#endif 指令跟#ifdef...#endif 正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作_**

```c
#ifdef EXTRA_HAPPY
    printf("I'm extra happy!\n");
#endif

#ifndef EXTRA_HAPPY
    printf("I'm just regular\n");
#endif

// 针对宏EXTRA_HAPPY是否被定义过，#ifdef和#ifndef分别指定了两种情况各自需要编译的代码
```

- **#ifndef 常用于防止重复加载**。举例来说，为了防止头文件 myheader.h 被重复加载，可以把它放在#ifndef...#endif 里面加载

```c
#ifndef MYHEADER_H
    #define MYHEADER_H
    #include "myheader.h"
#endif

// 宏MYHEADER_H对应文件名myheader.h的大写。只要#ifndef发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏MYHEADER_H，防止被再次加载。
```

- **#ifndef 等同于#if !defined**

```c
#ifndef FOO
// 等同于
#if !defined FOO
```

#### 10.预定义宏

- C 语言提供一些预定义的宏，可以直接使用

1. **DATE**：编译日期，格式为 Mmm dd yyyy 的字符串 (比如 Nov 23 2021)
2. **TIME**：编译时间，格式为 "hh:mm:ss"
3. **FILE**：当前文件名
4. **LINE**：当前行号
5. **func**：当前正在执行的函数名。该预定义宏必须在函数作用域使用
6. **STDC**：如果被设为 1，表示当前编译器遵循 C 标准
7. **STDC_HOSTED**：如果被设为 1，表示当前编译器可以提供完整的标准库；否则被设为 0 (嵌入式系统的标准库常常是不完整的)
8. **STDC_VERSION**：编译所使用的 C 语言版本，是一个格式为 yyyymmL 的长整数，C99 版本为 199901L，C11 版本为 201112L，C17 版本为 201710L
   > 下面示例打印这些预定义宏的值

```c
#include <stdio.h>

int main(void) {
    printf("This function: %s\n", __func__);
    printf("This file: %s\n", __FILE__);
    printf("This line: %d\n", __LINE__);
    printf("Compiled on: %s %s\n", __DATE__, __TIME__);
    printf("C Version: %ld\n", __STDC_VERSION__);
}
```

#### 11.#line

- **_#line 指令用于覆盖预定义宏**LINE**，将其改为自定义的行号。后面的行将从**LINE**的新值开始计数_**

```c
// 将下一行的行号重置为 300
#line 300

// 紧跟在#line 300后面一行的行号，将被改成300，其后的行会在300的基础上递增编号
```

- **_#line 还可以改掉预定义宏**FILE**，将其改为自定义的文件名_**

```c
#line 300 "newfilename"

// 下一行的行号重置为300，文件名重置为newfilename
```

#### 12.#error

- **_#error 指令用于让预处理器抛出一个错误，终止编译_**

```c
#if __STDC_VERSION__ != 201112L
    #error Not C11
#endif

// 如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错

$ gcc -std=c99 newish.c
newish.c:14:2: error: #error Not C11
```

```c
#if INT_MAX < 100000
    #error int type is too small
#endif

// 上面示例中，编译器一旦发现INT类型的最大值小于100,000，就会停止编译。
```

- **#error 指令也可以用在#if...#elif...#else 的部分**

```c
#if defined WIN32
    // ...
#elif defined MAC_OS
    // ...
#elif defined LINUX
    // ...
#else
    #error NOT support the operating system
#endif
```

#### 13.#pragma

- **_#pragma 指令用来修改编译器属性_**

```c
// 使用 C99 标准
#pragma c9x on

// 让编译器以 C99 标准进行编译
```

### 拾玖：I \ O 函数输入输出

> C 语言提供了一些函数，**_用于与外部设备通信，称为输入输出函数，简称 I/O 函数_**。输入 (import) 指的是获取外部数据，输出 (export) 指的是向外部传递数据

#### 1.缓存和字节流

> 严格地说，输入输出函数并不是直接与外部设备通信，而是**通过缓存 (buffer) 进行间接通信**

- 普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。C 语言的解决方案，就是**只要打开一个文件，就在内存里面为这个文件设置一个缓存区**
- 程序向文件写入数据时，**程序先把数据放入缓存，等到缓存满了，再把里面的数据会一次性写入磁盘文件**。这时，缓存区就空了，程序再把新的数据放入缓存，重复整个过程
- 程序从文件读取数据时，文件先把一部分数据放到缓存里面，然后程序从缓存获取数据，等到缓存空了，磁盘文件再把新的数据放入缓存，重复整个过程
- **内存的读写速度比磁盘快得多，缓存的设计减少了读写磁盘的次数**，大大提高了程序的执行效率。另外，一次性移动大块数据，要比多次移动小块数据快得多
- 这种读写模式，对于程序来说，就有点像水流（stream），不是一次性读取或写入所有数据，而是一个持续不断的过程。先操作一部分数据，等到缓存吞吐完这部分数据，再操作下一部分数据。这个过程就叫做字节流操作
- 由于缓存读完就空了，所以**字节流读取都是只能读一次，第二次就读不到了**。这跟读取文件很不一样
- C 语言的输入输出函数，凡是涉及读写文件，都是属于字节流操作。**输入函数从文件获取数据，操作的是输入流；输出函数向文件写入数据，操作的是输出流**
  > 你就想象相机的缓存，一次拍完要等一会清空在能继续写入

#### 2.printf()

> 请见第一章

#### 3.scanf()

- **_scanf()函数用于读取用户的键盘输入_**。程序运行到这个语句时，会停下来，等待用户从键盘输入。用户输入数据、按下回车键后，scanf()就会处理用户的输入，将其存入变量。**它的原型定义在头文件 stdio.h**，语法如下

```c
scanf("%d", &i);

// 它的第一个参数是一个格式字符串，里面会放置占位符 (与printf()的占位符基本一致)，告诉编译器如何解读用户的输入，需要提取的数据是什么类型
// 这是因为 C 语言的数据都是有类型的，scanf()必须提前知道用户输入的数据类型，才能处理数据
// 它的其余参数就是存放用户输入的变量，格式字符串里面有多少个占位符，就有多少个变量

// 上面示例中，scanf()的第一个参数%d，表示用户输入的应该是一个整数。%d就是一个占位符，%是占位符的标志，d表示整数。第二个参数&i表示，将用户从键盘输入的整数存入变量i

// 注意，变量前面必须加上&运算符 (指针变量除外)，因为scanf()传递的不是值，而是地址，即将变量i的地址指向用户输入的值。如果这里的变量是指针变量 (比如字符串变量)，那就不用加&运算符
```

- scanf()处理用户输入的原理是，**用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读。解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止**
  > 这里有些易混淆点，请看下面实例

```c
// p1

#include <stdio.h>

int main(int argc, char const *argv[]){
	int a, b, c;
	scanf("%d%d%d", &a, &b, &c);
	printf("%d,%d,%d\n", a, b, c);

    return 0;
}

// 接受以下输入

>>> .\a
1 2 3
1,2,3
>>> .\a
1
2
3
1,2,3
>>> .\a
1       2       3
1,2,3
```

> 当使用"%d%d%d"这种输入格式时，**_输入可以是一个空格或者多个空格、tab 键、回车键分割。输出都是正确的_**

```c
// p2

#include <stdio.h>

int main(int argc, char const *argv[]){
	int a, b, c;
	scanf("%d,%d,%d", &a, &b, &c);
	printf("%d,%d,%d\n", a, b, c);

    return 0;
}

// 接受以下输入

>>> .\a
1,2,3
1,2,3
>>> .\a
1,      2,      3
1,2,3
```

> "%d,%d,%d"格式与"%d%d%d"格式基本相同，不同之处在"%d,%d,%d"**_这种格式在输入时 ，一定要紧跟输入的数字，这里输入的逗号 , 一定要是英文的_**

```c
// p3

#include <stdio.h>

int main(int argc, char const *argv[]){
	int a, b, c;
	scanf("a=%d,b=%d,c=%d", &a, &b, &c);
	printf("%d,%d,%d\n", a, b, c);

    return 0;
}

>>> .\a
a=1,b=2,c=3

// 也要完全对应，如果格式不同便是出现意想不到的效果
```

```c
// p4

#include <stdio.h>

int main(int argc, char const *argv[]){
	char a, b, c;
	scanf("%c%c%c", &a, &b, &c);
	printf("%c,%c,%c\n", a, b, c);

    return 0;
}

// 这里存在一个输入问题时，在"%c"输入时，空格和转义字符均作为有效字符

>>> .\a
1 2 3
1, ,2

// 因为把空格作为字符接受了，a->1,b->" ",c->2，其余的被丢弃

// 还有

#include <stdio.h>

int main(int argc, char const *argv[]){
	int a;
	char c;
	scanf("%d", &a);
	scanf("%c", &c);
	printf("a=%d,  c=%c,\n", a, c);
	printf("c=%d\n", c);

    return 0;
}

>>> .\a
1  // 这是输入
a=1,  c=
,
c=10

// 这里输入1回车就会出现如上结果
// 这是因为scanf()从键盘接受数据将回车\n也接受了，所以c=\n，最后%d输出c的值就是10

// 解决办法，在%c之前加上空格，空格可以吸收回车制表和空格

int main(int argc, char const *argv[]){
	int a;
	char c;
	scanf("%d", &a);
	scanf(" %c", &c);
	printf("a=%d,  c=%c,\n", a, c);
	printf("c=%d\n", c);

    return 0;
}
```

```c
// p5

#include <stdio.h>

int main(int argc, char const *argv[]){
	char arr[20];
	scanf("%s", arr);
	printf("%s", arr);

    return 0;
}

>>> .\a
hello world // 输入
hello

// 是以下问题之一
1.遇见空格、回车、跳格
2.遇见宽度
3.遇见非法输入

// 解决办法使用正则表达式，这个以后讲web时会再深入讲，这里先知道一个语法就行
```

- **_字符扫描集是用于字符串读取的一个工具，它可以比%s 更灵活地控制读取过程，具体如下_**
- **_%[]的中括号中需要填写一个正则表达式_**，用于指明只读取那些字符或者不读取那些字符，**当中括号内的内容不是以^开头的时候，表示只读取在中括号中出现的内容，当遇到第一个没有出现的字符时，就停止读取，并把目前已经读取的内容保存到对应的字符数组中**，例如：

```c
char a[80];
scanf("%[0-9]",a); //只读取数字

// 假设输入为：
123a456

// 那么上面的scanf()将把123读取并保存到a数组中，其余的a456将遗留在缓冲区中

// 如果把上面的scanf()调用改为如下形式：
scanf("%[13579]",a);

// 并且输入如下：
123

// 那么将只读取1，并把它做为字符串保存到a 中，其余字符将遗留在缓冲区中，因为第二个字符2没有出现在扫描集中，所以不再继续读取
```

- **_如果扫描集的第一个字符是^，那么读取规则就变成了只读取没有出现在扫描集中的字符，遇到第一个出现在扫描集中的字符时，读取即告停止_**，例如：

```c
scanf("%[^0-9]",a);

// 这个调用将只读取非数字字符，遇到数字字符时读取停止，如果输入的是：
abc009icp

// 那么将读取abc到a数组，其余的字符将遗留在缓冲区中
```

- 这样就可以过滤掉回车符了

```c
#include <stdio.h>

int main(int argc, char const *argv[]){
	char arr[20];
	scanf("%[^\n]", arr);
	printf("%s", arr);

    return 0;
}
```

```c
// p6

#include <stdio.h>

int main(int argc, char const *argv[]){
    int x;
    float y;

    scanf("%d", &x);
    scanf("%f", &y);
    printf("%d\n",x);
    printf("%f\n",y);

    return 0;
}

>>> .\a
    -13.4545e4 // 这是输入
-13
4545.000000

// scanf()读取用户输入时，%d占位符会忽略起首的空格，从-处开始获取数据，读取到-13停下来，因为后面的.不属于整数的有效字符。这就是说，占位符%d会读到-13
// scanf()时，就会从上一次停止解读的地方，继续往下读取。这一次读取的首字符是.，由于对应的占位符是%f，会读取到.4545e4，这是采用科学计数法的浮点数格式。后面的#不属于浮点数的有效字符，所以会停在这里

// 由于scanf()可以连续处理多个占位符，所以上面的例子也可以写成下面这样

scanf("%d%f", &x, &y);
```

> 使用 scanf 请一定注意缓存区状态

- **_scanf()的返回值是一个整数，表示成功读取的变量个数。如果没有读取任何项，或者匹配失败，则返回 0。如果读取到文件结尾，则返回常量 EOF_**
  > 什么是 EOF 请看下面举例

```c
#include <stdio.h>

int main(int argc, char const *argv[]){
	int a,b;

	while(scanf("%d %d",&a,&b) != EOF){
		printf("%d\n",a+b);
    }

    return 0;
}

// EOF的官方解释
// 计算机术语，缩写通常为EOF (End Of File)，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。在C语言中，或更精确地说成C标准函式库中表示文件结束符 (end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~255，不可能出现-1，因此可以用EOF作为文件结束标志

// 1.
// 输入1 2然后回车打印出3

// 2.
// 输入1然后回车，它会让你继续输入，在这期间不论你空格键，回车键，TAB键只要是你没输入一个非空白符它就会让你无限输入，之前讲过空格可以吸收回车空格或制表

// 3.
// 输入1 2 3 4 5 6 7 8，然后回车，它会打印出3 7 11 15

// 4.
// 输入，. ~等字符回车，会进入无限循环屏幕上打印无限的数字，这是因为输入一个字符串时，由于scanf需要一个整型数据，可是当前输入缓冲中的数据并不是一个整型的数据，那么scanf会直接退出，并返回0，表示读到0个数，同时不会改为输入缓冲，会进入到下一轮的循环之中，在屏幕输出：上一次的计算结果，这时由于输入缓冲中还有数据，scanf不会阻塞，而是直接返回，可是发现缓冲中的数据不是所要的数据，这样返回0.....使得循环一直运行下去。要是想解决问题可以在循环语句中加上这句话：fflush(stdin);这样就不会无限打印数字了

// 至于想退出，在windows下输入ctrl+Z(即EOF)然后回车就可以了
```

> 因此 EOF 也可以用来做用户退出操作

- **_scanf 的占位符_**
  - %c：字符
  - %d：整数
  - %f：float 类型浮点数
  - %lf：double 类型浮点数
  - %Lf：long double 类型浮点数
  - %s：字符串
  - %[]：在方括号中指定一组匹配的字符（比如%[0-9]），遇到不在集合之中的字符，匹配将会停止
- 上面所有占位符之中，**_除了%c 以外，都会自动忽略起首的空白字符。%c 不忽略空白字符，总是返回当前第一个字符，无论该字符是否为空格_**。如果要强制跳过字符前的空白字符，可以写成 scanf(" %c", &ch)，**即%c 前加上一个空格，表示跳过零个或多个空白字符**，讲过再说一遍
- 下面要特别说一下占位符%s，它其实不能简单地等同于字符串。它的规则是，**_从当前第一个非空白字符开始读起，直到遇到空白字符 (即空格、换行符、制表符等)为止_**。因为%s 不会包含空白字符，所以无法用来读取多个单词，除非多个%s 一起使用。这也意味着，scanf()不适合读取可能包含空格的字符串，比如书名或歌曲名。另外，**_scanf()遇到%s 占位符，会在字符串变量末尾存储一个空字符\0_**
- **scanf()将字符串读入字符数组时，不会检测字符串是否超过了数组长度。所以，储存字符串时，很可能会超过数组的边界，导致预想不到的结果**。为了防止这种情况，**使用%s 占位符时，应该指定读入字符串的最长长度，即写成%[m]s，其中的[m]是一个整数，表示读取字符串的最大长度，后面的字符将被丢弃**

```c
char name[11];
scanf("%10s", name);

// name是一个长度为11的字符数组，scanf()的占位符%10s表示最多读取用户输入的10个字符，后面的字符将被丢弃，这样就不会有数组溢出的风险了
```

- 赋值忽略符，有时，用户的输入可能不符合预定的格式

```c
scanf("%d-%d-%d", &year, &month, &day);

// 如果用户输入2020-01-01，就会正确解读出年、月、日。问题是用户可能输入其他格式，比如2020/01/01，这种情况下，scanf()解析数据就会失败
```

- 为了避免这种情况，**_scanf()提供了一个赋值忽略符 (assignment suppression character)_。只要把*加在任何占位符的百分号后面，该占位符就不会返回值，解析后将被丢弃***

```c
scanf("%d%*c%d%*c%d", &year, &month, &day);

// %*c就是在占位符的百分号后面，加入了赋值忽略符*，表示这个占位符没有对应的变量，解读后不必返回
```

#### 4.sscanf()

- **_sscanf()函数与 scanf()很类似，不同之处是 sscanf()从字符串里面，而不是从用户输入获取数据_**。它的**原型定义在头文件 stdio.h 里面**

```c
int sscanf(const char* s, const char* format, ...);
```

- **_sscanf()的第一个参数是一个字符串指针，用来从其中获取数据。其他参数都与 scanf()相同_**
- sscanf()主要用来处理其他输入函数读入的字符串，从其中提取数据

```c
fgets(str, sizeof(str), stdin);
sscanf(str, "%d%d", &i, &j);

// fgets()先从标准输入获取了一行数据 (fgets()的介绍详见下一章)，存入字符数组str。然后，sscanf()再从字符串str里面提取两个整数，放入变量i和j
```

- **_sscanf()的一个好处是，它的数据来源不是流数据，所以可以反复使用_**，不像 scanf()的数据来源是流数据，只能读取一次
- **_sscanf()的返回值是成功赋值的变量的数量_**，如果提取失败，返回常量 EOF

#### 5.getchar()

- **_getchar()函数返回用户从键盘输入的一个字符_**，使用时不带有任何参数。程序运行到这个命令就会暂停，等待用户从键盘输入，等同于使用 scanf()方法读取一个字符。它的**原型定义在头文件 stdio.h**

```c
char ch;
ch = getchar();

// 等同于
scanf("%c", &ch);
```

- getchar**_会先从缓存区寻找有没有字符，没有的话才会等待键盘输入_**，所以**_要注意 getchar 会不会读到上次输入之后留下的垃圾值，比如回车，空格一类_**

```c
int len = 0;
while(getchar() != '\n')
    len++;

// 这就是利用这个特性计算用户输入的字符长度，一次一次循环直到读取到回车
```

- **_getchar()不会忽略起首的空白字符，总是返回当前读取的第一个字符，无论是否为空格_**。如果读取失败，返回常量 EOF，由于 EOF 通常是-1，所以**_返回值的类型要设为 int，而不是 char_**

#### 6.putchar()

- **_putchar()函数将它的参数字符输出到屏幕，等同于使用 printf()输出一个字符_**。它的原型定义在**头文件 stdio.h**

```c
putchar(ch);
// 等同于
printf("%c", ch);

// 操作成功时，putchar()返回输出的字符，否则返回常量 EOF
```

- 由于 getchar()和 putchar()这两个函数的用法，要比 scanf()和 printf()更简单，而且通常是用宏来实现，所以要比 scanf()和 printf()更快。**_如果操作单个字符，建议优先使用这两个函数_**

#### 7.puts()

- **puts()函数用于将参数字符串显示在屏幕 (stdout)上，并且自动在字符串末尾添加换行符\***。它的原型定义在**头文件 stdio.h**

```c
puts("Here are some messages:");
puts("Hello World");

// puts()在屏幕上输出两行内容。
```

> 这个函数也很简单，**只有一个参数**，而且自带换行，但是不能有其他参数实在是一言难尽，你就不能再加一个吗？

- **_写入成功时，puts()返回一个非负整数，否则返回常量 EOF_**

#### 8.gets()

- **_gets()函数以前用于从 stdin 读取整行输入，现在已经被废除了_**，仍然放在这里介绍一下
- **_该函数读取用户的一行输入，不会跳过起始处的空白字符，直到遇到换行符为止。这个函数会丢弃换行符，将其余字符放入参数变量，并在这些字符的末尾添加一个空字符\0，使其成为一个字符串_**
  > 它经常与 puts()配合使用

```c
char words[81];

puts("Enter a string, please");
gets(words);

// 使用puts()在屏幕上输出提示，然后使用gets()获取用户的输入。
```

- 由于 gets()获取的字符串，**_可能超过字符数组变量的最大长度，有安全风险，建议不要使用_**，改为使用 fgets()

### 贰拾：命令行参数

#### 1.main 函数的参数

- **_C 语言程序可以从命令行启动接收参数_**

```c
$ ./foo hello world

// 程序foo接收了两个命令行参数hello和world
```

> 那这个参数从哪里拿呢?之前好久没讲过 main 函数的参数是什么对吧，没错就是命令行参数

```c
#include <stdio.h>

int main(int argc, char* argv[]) {
    for (int i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }
}
```

- **_main()函数有两个参数 argc (argument count) 和 argv (argument variable)_**。这两个参数的名字可以任意取，但是一般来说，约定俗成就是使用这两个词
- 第一个参数**_argc 是命令行参数的数量_**，由于**程序名也被计算在内**，所以严格地说**_argc 是参数数量 + 1_**
- 第二个参数**_argv 是一个数组，保存了所有的命令行输入，它的每个成员是一个字符串指针_**
  > 以 _./a.c hello world_ 为例，argc 是 3，表示命令行输入有三个组成部分：./foo、hello、world。数组 argv 用来获取这些输入，argv[0]是程序名./foo，argv[1]是 hello，argv[2]是 world。一般来说，argv[1]到 argv[argc - 1]依次是命令行的所有参数。argv[argc]则是一个空指针 NULL
- 由于字符串指针可以看成是字符数组，所以下面两种写法是等价的

```c
// 写法一
int main(int argc, char* argv[])

// 写法二
int main(int argc, char** argv)
// 不过一般用写法一

// 另一方面，每个命令行参数既可以写成数组形式argv[i]，也可以写成指针形式*(argv + i)
```

- 利用 argc，**可以限定函数只能有多少个参数**

```c
#include <stdio.h>

int main(int argc, char** argv) {
    if (argc != 3) {
        printf("usage: mult x y\n");
        return 1;
    }

    printf("%d\n", atoi(argv[1]) * atoi(argv[2]));
    return 0;
}

// argc不等于3就会报错，这样就限定了程序必须有两个参数，才能运行
```

- 另外，**argv 数组的最后一个成员是 NULL 指针 (argv[argc] == NULL)**。所以，参数的遍历也可以写成下面这样

```c
for (char** p = argv; *p != NULL; p++) {
    printf("arg: %s\n", *p);
}

// 指针p依次移动，指向argv的每个成员，一旦移到空指针 NULL，就表示遍历结束。由于argv的地址是固定的，不能执行自增运算（argv++），所以必须通过一个中间变量p，完成遍历操作
```

- C 语言规定，**_如果 main()函数没有 return 语句，那么结束运行的时候，默认会添加一句 return 0，即返回整数 0_**。这就是为什么 main()语句通常约定返回一个整数值，并且返回整数 0 表示程序运行成功。如果**_返回非零值，就表示程序运行出了问题_**
  > 注意，**只有 main()会默认添加 return 0，其他函数都没有这个机制**，为了方便阅读方便 main 会加上 return 语句

#### 2.读取

- C 语言提供了**_getenv()函数 (原型在 stdlib.h) 用来读取命令行环境变量_**

```c
#include <stdio.h>
#include <stdlib.h>

int main (void){
   printf("PATH : %s\n", getenv("PATH"));
   printf("HOME : %s\n", getenv("HOME"));
   printf("ROOT : %s\n", getenv("ROOT"));

   return(0);
}

// 一般配置PATH还会有其他程序，所以打印出来会很多
// HOME不配置会打印null
// 也可以打印其他环境变量，只要名字对的上

printf("ROOT : %s\n", getenv("JAVA_HOME"));
```

### 贰拾壹：文件操作

> 带我再研究研究

## 第五章：库函数与开发

> 下次讲

# C++入门

> 没时间啊
